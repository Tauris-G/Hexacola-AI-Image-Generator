<!DOCTYPE html>
<html lang="lt">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Storyboard - HEXACOLA AI</title>
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">

  <!-- I≈°orinƒós bibliotekos PDF, vaizdo konvertavimui ir ZIP failams -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.3.2/html2canvas.min.js" integrity="sha512-i2tAVXwcquMA3VT9SBO3lXny30YA6E6o61fzKTN5DFNIGonRIClALlsvf0YJbI8LL0zC2ItHyhhz/v93C9e5Zg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

</head>
<body>
  <div class="main-wrapper">
    <aside class="sidebar">
      <h2>Storyboard</h2>
      <div class="input-group">
        <label>Bendra Istorija:</label>
        <textarea id="scenarioInput" placeholder="Para≈°ykite savo istorijos scenarij≈≥ ƒçia..."></textarea>
      </div>
      <div class="input-group">
        <label>Stilius:</label>
        <select id="styleSelection">
          <option value="None">None</option>
          <option value="Film">Film</option>
          <option value="Pixel Art">Pixel Art</option>
          <option value="Anime">Anime</option>
          <option value="Realistic">Realistic</option>
          <option value="Mix">Mix</option>
          <option value="Storyboard">Storyboard</option>
          <option value="Film Noir">Film Noir</option>
          <option value="Vintage">Vintage</option>
          <option value="Graphic Design">Graphic Design</option>
          <option value="Cartoon">Cartoon</option>
          <option value="Watercolor">Watercolor</option>
          <option value="Surrealism">Surrealism</option>
          <option value="Comics Style">Comics Style</option>
        </select>
      </div>
      <div class="input-group">
        <label>Modelis:</label>
        <select id="modelSelection">
          <option value="flux" selected>Pagrindinis</option>
          <option value="flux-anime">Anime</option>
          <option value="flux-3d">3D</option>
          <option value="flux-pro">Pa≈æangus</option>
          <option value="flux-realism">Realizmas</option>
          <option value="flux-cablyal">Detalus</option>
          <option value="any-dark">Tamsus</option>
          <option value="turbo">Greitas</option>
          <option value="Unity">Pa≈°ƒólƒôs</option>
        </select>
      </div>
      <div class="input-group">
        <button class="generate tooltip" onclick="addFrame()">
          <i class="fas fa-plus"></i> PRIDƒñTI RƒñMELƒÆ
          <span class="tooltiptext">Pridƒóti naujƒÖ rƒómelƒØ</span>
        </button>
      </div>
      <div class="buttons">
        <button class="generate tooltip" onclick="generateStoryboard()">
          <i class="fas fa-magic"></i> GENERUOTI STORYBOARD
        </button>
        <button class="generate tooltip" onclick="saveStoryboard()">
          <i class="fas fa-save"></i> I≈†SAUGOTI
        </button>
        <button class="download tooltip" onclick="downloadStoryboardPDF()">
          <i class="fas fa-file-pdf"></i> PDF
        </button>
        <button class="download tooltip" onclick="downloadStoryboardZIP()">
          <i class="fas fa-file-zipper"></i> ZIP
        </button>
        <button class="generate tooltip" onclick="goToGenerator()">
          <i class="fas fa-arrow-left"></i> GENERATOR
        </button>
      </div>
      <div class="buttons">
        <button class="auto-toggle tooltip" onclick="toggleAutoPrompt()" id="autoPromptBtn" data-tooltip="Automati≈°kai generuoti prompt'us" aria-pressed="false">
          <i class="fas fa-robot"></i> AUTO OFF
        </button>
        <button class="dark-mode-toggle tooltip" onclick="toggleDarkMode()">
          <i class="fas fa-moon"></i> üåô
        </button>
      </div>
    </aside>
    <main class="container active" id="storyboardContainer">
      <div class="header">
        <h1>Storyboard Generator</h1>
      </div>
      <div class="generated-image" id="storyboardFrames"></div>
    </main>
  </div>

  <div id="imageModal" class="modal">
    <span class="close">&times;</span>
    <img class="modal-content" id="modalImage" alt="Didelis vaizdas">
  </div>

  <div class="overlay" id="overlay">
    <div class="loader"></div>
    <div id="loading">Generuojama...</div>
    <div class="progress-container">
      <div class="progress-bar" id="progressBar"></div>
    </div>
  </div>

  <script src="app.js"></script>
  <script>
    let currentFrameCount = 0;
    let autoPromptEnabled = false;
    let globalCharacters = "";
    let globalLocation = "";
    let storyOutline = []; 

    document.addEventListener('DOMContentLoaded', () => {
      loadStoryboard();
      loadDarkMode();
      loadAutoPrompt();
      setupModal();
      disableImageDownload();
    });

    async function generateGlobalDetails(scenario, style) {
      const promptForAPI = `
      You are a helpful AI assistant. Return strictly valid JSON with keys and values only, no code blocks.
      Scenario: "${scenario}"
      Style: "${style}"
      Extract globalCharacters and globalLocation. Must include detailed clothing, hair, eye color, accessories for characters and background details for location.
      These details must not change across frames unless outline says so.
      Return exactly: { "globalCharacters": "..." , "globalLocation": "..." }
      `;
      return await callOpenAIAPI(promptForAPI);
    }

    async function generateStoryOutline(scenario, framesCount) {
      const promptForAPI = `
      You are a helpful AI assistant. Return strictly valid JSON with keys and values only, no code blocks.
      Scenario: "${scenario}"
      ${framesCount} frames.
      Outline story into ${framesCount} chronological moments.
      Each frame must differ in emotion, action, camera shot, but keep same style and same global chars/loc details.
      Return exactly: { "outline": ["frame1", "frame2", ...] }
      `;
      return await callOpenAIAPI(promptForAPI);
    }

    async function callOpenAIAPI(userMessage) {
      try {
        const response = await fetch('https://text.pollinations.ai/openai', {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({
            messages:[
              {role:'system',content:'You produce strictly valid JSON with keys and string values only. No code blocks. The JSON must have exactly the requested keys. Each response must reflect chosen style, maintain identical character/location details, differ each frame in camera, emotion, action. Return only the requested fields.'},
              {role:'user',content:userMessage}
            ],
            model:'openai',
            seed:Math.floor(Math.random()*100000),
            jsonMode:false
          })
        });

        if(!response.ok) {
          console.error('API klaida:', response.status, response.statusText);
          return null;
        }

        const data=await response.json();
        if(data.choices && data.choices.length>0 && data.choices[0].message) {
          let content = data.choices[0].message.content.trim();
          content = content.replace(/```/g,'').trim();
          try {
            const obj = JSON.parse(content);
            return obj;
          } catch(e) {
            console.error('JSON parse klaida:', e, 'JSON content was:', content);
            alert("Klaida apdorojant AI atsakymƒÖ. Bandykite kitƒÖ scenarij≈≥ arba pakartokite veiksmƒÖ.");
            return null;
          }
        }
        return null;
      } catch(err) {
        console.error('fetch klaida:', err);
        return null;
      }
    }

    async function generateAutoFrameDetails(frameNumber) {
      const scenario = document.getElementById('scenarioInput').value.trim();
      const style = document.getElementById('styleSelection').value;
      if(!scenario) return null;

      const emotion = document.getElementById(`emotion-${frameNumber}`)?.value.trim() || "neutral";
      const cameraValue = document.getElementById(`camera-${frameNumber}`)?.value || "";
      const charsValue = document.getElementById(`characters-${frameNumber}`)?.value.trim() || "";
      const locValue = document.getElementById(`location-${frameNumber}`)?.value.trim() || "";
      const framePlot = storyOutline[frameNumber - 1] || "This frame continues the story logically.";

      const promptForAPI = `
      You are a helpful AI assistant. Return strictly valid JSON with EXACT keys: "emotion","characters","location","camera","action","prompt","narration".
      No extra keys, no code blocks.
      Scenario: "${scenario}"
      Global: Characters="${globalCharacters}", Location="${globalLocation}"
      Frame ${frameNumber} outline: "${framePlot}"
      Style: "${style}"

      Additional requirements:
      - Maintain correct perspective, composition, and proportions.
      - Negative prompt: "low quality, blurry, disfigured, extra limbs, watermark, text overlay, ugly, incorrect perspective, disproportionate".
      - The image should be high-quality, stylized as chosen, with correct proportions and no negative elements.

      Requirements:
      - "emotion": string
      - "characters": string 
      - "location": string
      - "camera": string
      - "action": string
      - "prompt": string (include style and ensure correctness)
      - "narration": string (short line describing scene or dialogue)

      Each frame differs in emotion, action, camera.
      `;

      return await callOpenAIAPI(promptForAPI);
    }

    async function generateFrameWithNarration(frameNumber) {
      const scenario = document.getElementById('scenarioInput').value.trim();
      const style = document.getElementById('styleSelection').value;
      if(!scenario) return null;

      const emotion = document.getElementById(`emotion-${frameNumber}`)?.value.trim() || "neutral";
      const cameraValue = document.getElementById(`camera-${frameNumber}`)?.value || "";
      const charsValue = document.getElementById(`characters-${frameNumber}`)?.value.trim() || "";
      const locValue = document.getElementById(`location-${frameNumber}`)?.value.trim() || "";
      const framePlot = storyOutline[frameNumber - 1] || "This frame continues the story logically.";

      const promptForAPI = `
      You are a helpful AI assistant. Return strictly valid JSON with EXACT keys: "emotion","characters","location","camera","action","prompt","narration".
      No extra keys, no code blocks.
      Scenario: "${scenario}"
      Global: Characters="${globalCharacters}", Location="${globalLocation}"
      Frame ${frameNumber} outline: "${framePlot}"
      Style: "${style}"

      Additional requirements:
      - Maintain correct perspective, composition, and proportions.
      - Negative prompt: "low quality, blurry, disfigured, extra limbs, watermark, text overlay, ugly, incorrect perspective, disproportionate".
      - High-quality image in chosen style.

      Requirements:
      - "emotion": string
      - "characters": string
      - "location": string
      - "camera": string
      - "action": string
      - "prompt": string
      - "narration": string

      Each frame differs in emotion, action, camera. Narration suits the scene.
      `;

      return await callOpenAIAPI(promptForAPI);
    }

    function addFrame() {
      if (currentFrameCount >= 10) {
        alert('Galite pridƒóti tik 10 rƒómeli≈≥.');
        return;
      }
      currentFrameCount++;
      const framesContainer = document.getElementById('storyboardFrames');
      const frame = document.createElement('div');
      frame.classList.add('image-container');
      frame.setAttribute('id', `frame-${currentFrameCount}`);
      frame.innerHTML = `
        <h3>Rƒómelis ${currentFrameCount}</h3>
        <button class="remove-frame-btn tooltip" onclick="removeFrame(${currentFrameCount})" aria-label="Pa≈°alinti rƒómelƒØ">
          <i class="fas fa-trash-alt"></i>
          <span class="tooltiptext">Pa≈°alinti rƒómelƒØ</span>
        </button>
        <div class="input-group">
          <label for="emotion-${currentFrameCount}">Emocija:</label>
          <input type="text" id="emotion-${currentFrameCount}" placeholder="Pvz., d≈æiaugsmas..." />
        </div>
        <div class="input-group">
          <label for="camera-${currentFrameCount}">Kameros Planas:</label>
          <select id="camera-${currentFrameCount}">
            <option value="">Pasirinkite</option>
            <option value="Wide Shot">Wide Shot</option>
            <option value="Close-Up">Close-Up</option>
            <option value="Extreme Close-Up">Extreme Close-Up</option>
            <option value="Dolly Shot">Dolly Shot</option>
            <option value="Point of View">Point of View</option>
            <option value="Tilt">Tilt</option>
            <option value="Panorama">Panorama</option>
            <option value="Drone Shot">Drone Shot</option>
            <option value="Focus Pull">Focus Pull</option>
            <option value="Tracking Shot">Tracking Shot</option>
          </select>
        </div>
        <div class="input-group">
          <label for="characters-${currentFrameCount}">Persona≈æai:</label>
          <textarea id="characters-${currentFrameCount}" placeholder="Specifiniai persona≈æ≈≥ apra≈°ymai..." rows="2"></textarea>
        </div>
        <div class="input-group">
          <label for="location-${currentFrameCount}">Lokacija:</label>
          <input type="text" id="location-${currentFrameCount}" placeholder="Specifinƒó lokacija..." />
        </div>
        <div class="input-group">
          <label for="aspectRatio-${currentFrameCount}">Nuotraukos Santykis:</label>
          <select id="aspectRatio-${currentFrameCount}">
            <option value="16:9">16:9</option>
            <option value="4:3">4:3</option>
            <option value="9:16">9:16</option>
            <option value="1:1">1:1</option>
          </select>
        </div>
        <div class="input-group">
          <label>Sugeneruotas Vaizdas:</label>
          <img id="image-${currentFrameCount}" src="#" alt="Sugeneruotas vaizdas" style="display:none;cursor:pointer;" onclick="openModal(${currentFrameCount})" />
        </div>
        <div class="input-group narration-group" style="margin-top:10px; display:none;">
          <label>Naracija:</label>
          <div class="narration-text" id="narration-${currentFrameCount}" style="font-style:italic;"></div>
        </div>
        <input type="hidden" id="prompt-${currentFrameCount}" />
      `;
      framesContainer.appendChild(frame);
    }

    function fillFrameWithDetails(n, details){
      if(!details) return;
      const requiredKeys = ["emotion","characters","location","camera","action","prompt","narration"];
      for(const k of requiredKeys) {
        if(!details.hasOwnProperty(k) || typeof details[k]!=='string') {
          console.error(`Nepilni duomenys rƒómeliui ${n}`, details);
          return;
        }
      }

      document.getElementById(`emotion-${n}`).value = details.emotion;
      document.getElementById(`characters-${n}`).value = details.characters;
      document.getElementById(`location-${n}`).value = details.location;
      const camSelect=document.getElementById(`camera-${n}`);
      for(const opt of camSelect.options){
        if(opt.value===details.camera){
          camSelect.value=details.camera;
          break;
        }
      }

      let finalPrompt = details.prompt;
      if(details.action !== 'unknown' && details.action.trim()!==''){
        finalPrompt += " [Action: " + details.action + "]";
      }
      document.getElementById(`prompt-${n}`).value=finalPrompt;

      const narrationDiv = document.getElementById(`narration-${n}`);
      narrationDiv.textContent = details.narration;
      narrationDiv.parentElement.style.display = 'block';
    }

    async function autoGenerateFrameDetailsForAll() {
      const scenario = document.getElementById('scenarioInput').value.trim();
      const style = document.getElementById('styleSelection').value;
      if(!scenario) return; 

      const globalData = await generateGlobalDetails(scenario, style);
      if(!globalData || !globalData.globalCharacters || !globalData.globalLocation) {
        console.error("Nepavyko gauti globali≈≥ duomen≈≥. Pabandykite kitƒÖ scenarij≈≥.");
        return;
      }
      
      globalCharacters = globalData.globalCharacters;
      globalLocation = globalData.globalLocation;

      const outlineData = await generateStoryOutline(scenario, currentFrameCount);
      if(!outlineData || !outlineData.outline) {
        console.error("Nepavyko gauti istorijos plano. Bandykite kitƒÖ scenarij≈≥.");
        return;
      }
      
      storyOutline = outlineData.outline;

      for (let i=1; i<=currentFrameCount; i++){
        const details = await generateFrameWithNarration(i);
        if(details){
          fillFrameWithDetails(i, details);
        } else {
          console.error(`Nepavyko gauti duomen≈≥ rƒómeliui ${i}.`);
        }
      }
    }

    function removeFrame(num) {
      const frame = document.getElementById(`frame-${num}`);
      if (frame) {
        frame.remove();
        currentFrameCount--;
        const allFrames = document.querySelectorAll('.image-container[id^="frame-"]');
        allFrames.forEach((f, index) => {
          const newNum = index + 1;
          f.id = `frame-${newNum}`;
          f.querySelector('h3').textContent = `Rƒómelis ${newNum}`;
          f.querySelector('.remove-frame-btn').setAttribute('onclick', `removeFrame(${newNum})`);
          f.querySelectorAll('[id]').forEach(el => {
            el.id = el.id.replace(/\d+$/, newNum);
          });
          const img = f.querySelector('img[onclick]');
          if (img) img.setAttribute('onclick', `openModal(${newNum})`);
        });
      }
    }

    async function generateStoryboard() {
      const scenario = document.getElementById('scenarioInput').value.trim();
      if (!scenario) {
        alert('ƒÆveskite scenarij≈≥.');
        return;
      }
      if (currentFrameCount === 0) {
        alert('Pridƒókite bent vienƒÖ rƒómelƒØ.');
        return;
      }

      if(autoPromptEnabled && scenario!==''){
        await autoGenerateFrameDetailsForAll();
      }

      for (let i=1;i<=currentFrameCount;i++){
        const prompt=document.getElementById(`prompt-${i}`).value.trim();
        if(!prompt){
          alert(`Nepavyko sugeneruoti prompt rƒómeliui ${i}. ƒÆjunkite AUTO ON ir pateikite scenarij≈≥, arba suveskite rankiniu b≈´du.`);
          return;
        }
      }

      document.getElementById('overlay').style.display = 'flex';
      updateProgressBar(0);
      const model = document.getElementById('modelSelection').value;

      for (let i = 1; i <= currentFrameCount; i++) {
        const prompt = document.getElementById(`prompt-${i}`).value.trim();
        const aspect = document.getElementById(`aspectRatio-${i}`).value;
        let w, h;
        switch(aspect) {
          case '16:9': w=1920;h=1080;break;
          case '4:3': w=1600;h=1200;break;
          case '9:16': w=1080;h=1920;break;
          case '1:1': w=1080;h=1080;break;
          default: w=1024;h=1024;
        }
        const imgEl = document.getElementById(`image-${i}`);
        if (imgEl.src && imgEl.src !== '#' && imgEl.style.display === 'block') {
          updateProgressBar((i/currentFrameCount)*100);
          continue; 
        }

        let success = false;
        let attempts = 0;
        const maxAttempts = 3;
        while(!success && attempts < maxAttempts) {
          try {
            const imgUrl = await fetchImage(prompt, model, w, h);
            imgEl.src = imgUrl;
            imgEl.style.display = 'block';
            success = true;
          } catch(e) {
            attempts++;
            console.error(`Bandymas ${attempts}: Nepavyko gauti vaizdo rƒómeliui ${i}`, e);
            if(attempts >= maxAttempts) {
              alert(`Nepavyko gauti vaizdo rƒómeliui ${i} net po ${maxAttempts} bandym≈≥.`);
            }
          }
        }
        updateProgressBar((i/currentFrameCount)*100);
      }

      alert('Storyboard sugeneruotas!');
      document.getElementById('overlay').style.display = 'none';
    }

    async function fetchImage(prompt,model,w,h) {
      const enc = encodeURIComponent(prompt);
      const seed = Math.floor(Math.random()*100000);
      const url=`https://image.pollinations.ai/prompt/${enc}?model=${model}&seed=${seed}&width=${w}&height=${h}&nologo=true&private=false&enhance=true&safe=true`;
      const resp=await fetch(url);
      if(!resp.ok) throw new Error('Nepavyko gauti vaizdo.');
      const blob=await resp.blob();
      return URL.createObjectURL(blob);
    }

    function updateProgressBar(pct) {
      document.getElementById('progressBar').style.width = pct+'%';
    }

    function saveStoryboard() {
      const storyboard=[];
      for (let i=1;i<=currentFrameCount;i++){
        const frm=document.getElementById(`frame-${i}`);
        if(frm){
          const image=frm.querySelector('img').src;
          const emotion=frm.querySelector(`#emotion-${i}`).value.trim();
          const camera=frm.querySelector(`#camera-${i}`).value;
          const chars=frm.querySelector(`#characters-${i}`).value.trim();
          const loc=frm.querySelector(`#location-${i}`).value.trim();
          const fullPrompt=frm.querySelector(`#prompt-${i}`).value.trim();
          let action="unknown action";
          let purePrompt=fullPrompt;
          const actionMatch = fullPrompt.match(/\[Action:\s*(.*?)\]/);
          if(actionMatch && actionMatch[1]){
            action = actionMatch[1];
            purePrompt = fullPrompt.replace(/\[Action:.*?\]/,'').trim();
          }
          const pr=purePrompt;
          const asp=frm.querySelector(`#aspectRatio-${i}`).value;
          storyboard.push({image,emotion,camera,characters:chars,location:loc,action, prompt:pr,aspectRatio:asp});
        }
      }
      localStorage.setItem('storyboard',JSON.stringify(storyboard));
      alert('I≈°saugota!');
    }

    async function downloadStoryboardPDF() {
      const { jsPDF } = window.jspdf;
      if(currentFrameCount===0){alert('Nƒóra rƒómeli≈≥.');return;}
      const pdf=new jsPDF('p','mm','a4');
      let y=10;
      for(let i=1;i<=currentFrameCount;i++){
        const frm=document.getElementById(`frame-${i}`);
        if(frm){
          const canvas=await html2canvas(frm,{scale:2});
          const img=canvas.toDataURL('image/png');
          const props=pdf.getImageProperties(img);
          const pw=pdf.internal.pageSize.getWidth()-20;
          const ph=(props.height*pw)/props.width;
          if(y+ph>pdf.internal.pageSize.getHeight()){pdf.addPage();y=10;}
          pdf.addImage(img,'PNG',10,y,pw,ph);
          y+=ph+10;
        }
      }
      pdf.save('storyboard.pdf');
    }

    async function downloadStoryboardZIP() {
      if(currentFrameCount===0){alert('Nƒóra rƒómeli≈≥.');return;}
      const zip=new JSZip();
      const folder=zip.folder("images");
      const tasks=[];
      for(let i=1;i<=currentFrameCount;i++){
        const imgEl=document.getElementById(`image-${i}`);
        if(imgEl && imgEl.src && imgEl.src!=='#' && imgEl.src.startsWith('blob:')){
          const url=imgEl.src;
          const fname=`frame-${i}.png`;
          tasks.push(fetch(url).then(r=>r.blob()).then(b=>folder.file(fname,b)));
        }
      }
      try{
        await Promise.all(tasks);
        const data=await zip.generateAsync({type:"blob"});
        saveAs(data,"storyboard_images.zip");
      }catch(e){
        console.error(e);
        alert('Klaida kuriant ZIP.');
      }
    }

    function goToGenerator() {
      window.location.href='index.html';
    }

    function loadStoryboard() {
      const saved=JSON.parse(localStorage.getItem('storyboard'))||[];
      if(saved.length>0){
        saved.forEach((fr,i)=>{
          addFrame();
          const n=i+1;
          document.getElementById(`emotion-${n}`).value=fr.emotion;
          document.getElementById(`camera-${n}`).value=fr.camera;
          document.getElementById(`characters-${n}`).value=fr.characters;
          document.getElementById(`location-${n}`).value=fr.location;
          let reconstructedPrompt=fr.prompt;
          if(fr.action && fr.action!=='unknown action'){
            reconstructedPrompt += " [Action: "+fr.action+"]";
          }
          document.getElementById(`prompt-${n}`).value=reconstructedPrompt;
          document.getElementById(`aspectRatio-${n}`).value=fr.aspectRatio||'16:9';
          if(fr.image && fr.image!=='#'){
            const img=document.getElementById(`image-${n}`);
            img.src=fr.image;
            img.style.display='block';
          }
        });
      }
    }

    function openModal(n) {
      const imgSrc=document.getElementById(`image-${n}`).src;
      const modal=document.getElementById('imageModal');
      const modalImg=document.getElementById('modalImage');
      modal.style.display='flex';
      modalImg.src=imgSrc;
    }

    function setupModal() {
      const modal=document.getElementById('imageModal');
      const closeBtn=document.querySelector('.close');
      closeBtn.onclick=function(){modal.style.display='none';};
      window.onclick=function(e){if(e.target==modal){modal.style.display='none';}};
    }

    function disableImageDownload() {
      const images=document.querySelectorAll('#storyboardFrames img');
      images.forEach(img=>{
        img.oncontextmenu=(e)=>e.preventDefault();
        img.draggable=false;
      });
    }

    function toggleDarkMode() {
      document.body.classList.toggle('dark-mode');
      const darkBtn=document.querySelector('.dark-mode-toggle');
      if(document.body.classList.contains('dark-mode')){
        darkBtn.innerHTML='<i class="fas fa-sun"></i> ‚òÄÔ∏è';
        darkBtn.setAttribute('aria-label','≈†viesus re≈æimas');
      }else{
        darkBtn.innerHTML='<i class="fas fa-moon"></i> üåô';
        darkBtn.setAttribute('aria-label','Tamsus re≈æimas');
      }
      localStorage.setItem('darkMode',document.body.classList.contains('dark-mode'));
    }

    function loadDarkMode() {
      const dm=localStorage.getItem('darkMode');
      const darkBtn=document.querySelector('.dark-mode-toggle');
      if(dm==='true'){
        document.body.classList.add('dark-mode');
        darkBtn.innerHTML='<i class="fas fa-sun"></i> ‚òÄÔ∏è';
        darkBtn.setAttribute('aria-label','≈†viesus re≈æimas');
      }else{
        darkBtn.innerHTML='<i class="fas fa-moon"></i> üåô';
        darkBtn.setAttribute('aria-label','Tamsus re≈æimas');
      }
    }

    function toggleAutoPrompt() {
      autoPromptEnabled=!autoPromptEnabled;
      const btn=document.getElementById('autoPromptBtn');
      if(autoPromptEnabled){
        btn.classList.add('active');
        btn.innerHTML='<i class="fas fa-robot"></i> AUTO ON';
        btn.setAttribute('aria-pressed','true');
        localStorage.setItem('autoPrompt','enabled');
        const scenario=document.getElementById('scenarioInput').value.trim();
        if(scenario!==''){
          autoGenerateFrameDetailsForAll();
        }
      }else{
        btn.classList.remove('active');
        btn.innerHTML='<i class="fas fa-robot"></i> AUTO OFF';
        btn.setAttribute('aria-pressed','false');
        localStorage.setItem('autoPrompt','disabled');
      }
    }

    function loadAutoPrompt() {
      const ap=localStorage.getItem('autoPrompt');
      const btn=document.getElementById('autoPromptBtn');
      if(ap==='enabled'){
        autoPromptEnabled=true;
        btn.classList.add('active');
        btn.innerHTML='<i class="fas fa-robot"></i> AUTO ON';
        btn.setAttribute('aria-pressed','true');
      }else{
        autoPromptEnabled=false;
        btn.classList.remove('active');
        btn.innerHTML='<i class="fas fa-robot"></i> AUTO OFF';
        btn.setAttribute('aria-pressed','false');
      }
    }
  </script>
</body>
</html>
