<!DOCTYPE html>
<html lang="lt">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Hexacola AI Image Generator with Enhanced Features</title>
  <!-- Font Awesome for Icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
  <!-- Google Fonts for Modern Font -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <style>
    /* CSS Variables for Color Schemes */
    :root {
      --background-color: #1e1e1e;
      --text-color: #ffffff;
      --accent-color: #00ffcc;
      --accent-hover: #00e6b3;
      --sidebar-bg: rgba(30, 30, 30, 0.95);
      --sidebar-border: #444;
      --chat-bg: rgba(18, 18, 18, 0.95);
      --button-bg: #00ffcc;
      --button-hover: #00e6b3;
      --button-text: #ffffff;
      --toggle-active-bg: #00ffcc;
      --toggle-active-text: #1e1e1e;
      --overlay-bg: rgba(30, 30, 30, 0.8);
      --modal-bg: rgba(0,0,0,0.9);
      --caption-bg: rgba(0, 0, 0, 0.6);
      --progress-bar-color: #00ffcc;
      --loader-border: #00ffcc;
      --footer-text: #aaaaaa;
      --footer-link: #00ffcc;
    }

    /* Dark Mode Overrides */
    body.dark-mode {
      --background-color: #121212;
      --text-color: #e0e0e0;
      --sidebar-bg: rgba(18, 18, 18, 0.95);
      --sidebar-border: #666;
      --chat-bg: rgba(18, 18, 18, 0.95);
    }

    /* General Styles */
    body {
      margin: 0;
      font-family: 'Roboto', sans-serif;
      background-color: var(--background-color);
      color: var(--text-color);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      min-height: 100vh;
      transition: background-color 0.3s, color 0.3s;
      overflow: auto;
    }

    .main-wrapper {
      display: flex;
      width: 100%;
      max-width: 1200px;
      padding: 20px;
      box-sizing: border-box;
      flex: 1;
      flex-direction: row;
      gap: 20px;
    }

    /* Sidebar */
    .sidebar {
      flex: 1;
      max-width: 300px;
      background-color: var(--sidebar-bg);
      border: 2px solid var(--sidebar-border);
      border-radius: 15px;
      padding: 20px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.7);
      transition: background-color 0.3s, border-color 0.3s;
      display: flex;
      flex-direction: column;
      height: fit-content;
      overflow-y: auto;
    }

    .sidebar h2 {
      margin-top: 0;
      color: var(--accent-color);
      text-shadow: 0 0 5px rgba(0, 255, 204, 0.5);
      font-size: 1.5em;
    }

    /* Input Groups */
    .input-group {
      margin-bottom: 20px;
      text-align: left;
      position: relative;
    }

    .input-group label {
      display: block;
      margin-bottom: 8px;
      font-weight: bold;
      color: var(--accent-color);
      text-shadow: 0 0 5px rgba(0, 255, 204, 0.5);
    }

    .input-group button {
      width: 100%;
      padding: 10px;
      font-size: 1em;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: background-color 0.3s, transform 0.2s;
      color: var(--button-text);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
      margin-bottom: 10px;
    }

    .generate-prompt {
      background-color: var(--button-bg);
    }

    .generate-prompt:hover {
      background-color: var(--button-hover);
      transform: translateY(-2px);
    }

    /* Tooltip Styles */
    .tooltip {
      position: relative;
      display: inline-block;
    }

    .tooltip .tooltiptext {
      visibility: hidden;
      width: 160px;
      background-color: #555;
      color: #fff;
      text-align: center;
      border-radius: 6px;
      padding: 5px 0;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      margin-left: -80px;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }

    /* Library Button */
    .library-button {
      background-color: #007BFF;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
      transition: background-color 0.3s, transform 0.2s;
    }

    .library-button:hover {
      background-color: #0056b3;
      transform: translateY(-2px);
    }

    /* Chat Area */
    .chat {
      flex: 1;
      display: flex;
      flex-direction: column;
      background-color: var(--chat-bg);
      border: 2px solid var(--sidebar-border);
      border-radius: 15px;
      padding: 15px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.7);
      overflow-y: auto;
      margin-bottom: 20px;
      max-height: 300px;
    }

    .chat-message {
      margin-bottom: 15px;
      padding: 10px;
      border-radius: 8px;
      background-color: #333333;
      color: var(--text-color);
      word-wrap: break-word;
      white-space: pre-wrap;
      transition: background-color 0.3s;
    }

    .chat-message.user {
      background-color: #00b3a4;
      align-self: flex-end;
    }

    .chat-message.assistant {
      background-color: #555555;
      align-self: flex-start;
    }

    .chat-input-group {
      display: flex;
      gap: 10px;
    }

    .chat-input-group input {
      flex: 1;
      padding: 10px;
      border: 2px solid var(--accent-color);
      border-radius: 8px;
      background-color: #2c2c2c;
      color: var(--text-color);
      transition: background-color 0.3s, border-color 0.3s;
      box-shadow: inset 0 0 10px rgba(0, 255, 204, 0.1);
    }

    .chat-input-group input:focus {
      outline: none;
      border-color: var(--accent-hover);
    }

    .chat-input-group button {
      padding: 10px 15px;
      font-size: 1em;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: background-color 0.3s, transform 0.2s;
      color: var(--button-text);
      background-color: var(--button-bg);
      display: flex;
      align-items: center;
      gap: 5px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    }

    .chat-input-group button:hover {
      background-color: var(--button-hover);
      transform: translateY(-2px);
    }

    /* Main Container */
    .container, .library-container {
      flex: 2;
      background-color: var(--sidebar-bg);
      border: 2px solid var(--sidebar-border);
      border-radius: 15px;
      padding: 20px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.7);
      transition: background-color 0.3s, border-color 0.3s;
      position: relative;
      display: none;
      flex-direction: column;
      height: fit-content;
      overflow-y: auto;
    }

    .container.active, .library-container.active {
      display: flex;
    }

    .header {
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .header h1, .library-container h2 {
      font-size: 2em;
      margin: 0;
      color: var(--accent-color);
      text-shadow: 0 0 10px rgba(0, 255, 204, 0.7);
      text-align: center;
    }

    .input-group textarea, .input-group input, .input-group select {
      padding: 10px;
      border: 2px solid var(--accent-color);
      border-radius: 8px;
      resize: vertical;
      font-size: 1em;
      background-color: #2c2c2c;
      color: var(--text-color);
      transition: background-color 0.3s, border-color 0.3s;
      box-shadow: inset 0 0 10px rgba(0, 255, 204, 0.1);
      width: 100%;
      box-sizing: border-box;
    }

    .input-group textarea:focus, .input-group input:focus, .input-group select:focus {
      outline: none;
      border-color: var(--accent-hover);
    }

    /* Feature Toggles */
    .toggles {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 20px;
    }

    .toggle-group {
      display: flex;
      flex-direction: column;
      width: 48%;
      box-sizing: border-box;
    }

    .toggle-group label {
      margin-bottom: 8px;
      font-weight: bold;
      color: var(--accent-color);
      text-shadow: 0 0 5px rgba(0, 255, 204, 0.5);
    }

    .toggle-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
    }

    .toggle-buttons button {
      padding: 8px 12px;
      font-size: 0.9em;
      border: 2px solid var(--accent-color);
      border-radius: 20px;
      background-color: transparent;
      color: var(--accent-color);
      cursor: pointer;
      transition: background-color 0.3s, color 0.3s;
    }

    .toggle-buttons button.active {
      background-color: var(--toggle-active-bg);
      color: var(--toggle-active-text);
    }

    .toggle-buttons button:hover {
      background-color: var(--accent-hover);
      color: var(--toggle-active-text);
    }

    /* Camera Features and Colors Sections */
    .camera-color-section {
      margin-top: 20px;
    }

    .camera-color-section h2 {
      color: var(--accent-color);
      text-shadow: 0 0 5px rgba(0, 255, 204, 0.5);
      margin-bottom: 10px;
      font-size: 1.5em;
    }

    /* Description */
    .description {
      margin-bottom: 20px;
      padding: 10px;
      border: 1px solid #ccc;
      width: 100%;
      background-color: #2c2c2c;
      border-radius: 8px;
      color: var(--text-color);
      box-sizing: border-box;
      transition: background-color 0.3s, color 0.3s;
    }

    /* Buttons */
    .buttons {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    .buttons button {
      padding: 10px 20px;
      font-size: 1em;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: background-color 0.3s, transform 0.2s;
      color: var(--button-text);
      display: flex;
      align-items: center;
      gap: 8px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    }

    .buttons button.generate {
      background-color: var(--button-bg);
    }

    .buttons button.generate:hover {
      background-color: var(--button-hover);
      transform: translateY(-2px);
    }

    .buttons button.dark-mode-toggle {
      background-color: #555555;
    }

    .buttons button.dark-mode-toggle:hover {
      background-color: #777777;
      transform: translateY(-2px);
    }

    .buttons button.auto-toggle {
      background-color: #ffcc00;
      color: #000000;
      position: relative;
    }

    .buttons button.auto-toggle.active {
      background-color: #ffaa00;
    }

    .buttons button.auto-toggle:hover {
      background-color: #ffaa00;
      transform: translateY(-2px);
    }

    .buttons button.auto-toggle::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      background-color: #333;
      color: #fff;
      padding: 5px 10px;
      border-radius: 5px;
      white-space: nowrap;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
      font-size: 0.9em;
      z-index: 1;
    }

    .buttons button.auto-toggle:hover::after {
      opacity: 1;
    }

    .buttons button.clear-library {
      background-color: #ff4444;
    }

    .buttons button.clear-library:hover {
      background-color: #cc0000;
      transform: translateY(-2px);
    }

    /* Generated Images */
    .generated-image, .library-container .generated-image {
      margin-top: 20px;
      position: relative;
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      justify-content: center;
      overflow-y: auto;
      max-height: 400px;
    }

    .image-container {
      position: relative;
      width: 200px;
      flex-shrink: 0;
      border: 2px solid var(--accent-color);
      border-radius: 10px;
      overflow: hidden;
      transition: transform 0.3s, box-shadow 0.3s;
    }

    .image-container img {
      width: 100%;
      height: auto;
      cursor: pointer;
      transition: transform 0.3s, box-shadow 0.3s;
      filter: contrast(1.2) brightness(1.1) sepia(0.3) saturate(1.5) hue-rotate(-10deg);
      image-rendering: pixelated;
    }

    .image-container img:hover {
      transform: scale(1.05);
      box-shadow: 0 0 20px rgba(0, 255, 204, 0.7);
    }

    /* Caption */
    .caption {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      background: var(--caption-bg);
      color: var(--text-color);
      padding: 10px;
      box-sizing: border-box;
      border-bottom-left-radius: 10px;
      border-bottom-right-radius: 10px;
      font-size: 0.8em;
      opacity: 0;
      transition: opacity 0.3s;
      max-height: 50%;
      overflow: auto;
      text-align: left;
    }

    .image-container:hover .caption {
      opacity: 1;
    }

    /* Download Options */
    .download-options {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .download-options select,
    .download-options button {
      padding: 5px;
      font-size: 0.8em;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      background-color: rgba(255, 255, 255, 0.8);
      color: #000;
      transition: background-color 0.3s;
    }

    .download-options button:hover {
      background-color: rgba(255, 255, 255, 1);
    }

    /* Loader and Overlay */
    .loader {
      border: 8px solid #f3f3f3;
      border-top: 8px solid var(--loader-border);
      border-radius: 50%;
      width: 60px;
      height: 60px;
      animation: spin 1s linear infinite;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 10;
    }

    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--overlay-bg);
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 15px;
      z-index: 9;
      display: none;
      flex-direction: column;
      gap: 15px;
    }

    .progress-container {
      width: 80%;
      background-color: #555;
      border-radius: 25px;
      overflow: hidden;
      margin-top: 15px;
    }

    .progress-bar {
      height: 20px;
      width: 0%;
      background-color: var(--progress-bar-color);
      transition: width 0.3s;
    }

    @keyframes spin {
      0% { transform: rotate(0deg) translate(-50%, -50%); }
      100% { transform: rotate(360deg) translate(-50%, -50%); }
    }

    /* Footer */
    footer {
      margin-top: 20px;
      font-size: 0.8em;
      color: var(--footer-text);
      text-align: center;
      width: 100%;
    }

    footer a {
      color: var(--footer-link);
      text-decoration: none;
      font-weight: bold;
    }

    footer a:hover {
      text-decoration: underline;
    }

    /* Responsive */
    @media (max-width: 1200px) {
      .main-wrapper {
        flex-direction: column;
        align-items: center;
      }

      .sidebar {
        max-width: none;
        margin-right: 0;
        margin-bottom: 20px;
        width: 100%;
      }

      .container, .library-container {
        width: 100%;
      }

      .toggle-group {
        width: 100%;
      }
    }

    @media (max-width: 900px) {
      .chat {
        max-height: 200px;
      }

      .generated-image, .library-container .generated-image {
        max-height: 300px;
      }
    }

    @media (max-width: 600px) {
      .buttons {
        flex-direction: column;
        gap: 15px;
      }

      .loader {
        width: 40px;
        height: 40px;
        border-width: 6px;
      }

      .image-container {
        width: 100%;
      }

      .caption {
        font-size: 0.8em;
        padding: 8px;
      }

      .progress-container {
        width: 90%;
      }

      .download-options {
        flex-direction: column;
      }
    }

    /* Modal Styles */
    .modal {
      display: none;
      position: fixed;
      z-index: 100;
      padding-top: 60px;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: var(--modal-bg);
    }

    .modal-content {
      margin: auto;
      display: block;
      width: 80%;
      max-width: 1000px;
      animation-name: zoom;
      animation-duration: 0.6s;
    }

    #caption {  
      animation-name: zoom;
      animation-duration: 0.6s;
    }

    @keyframes zoom {
      from {transform:scale(0)} 
      to {transform:scale(1)}
    }

    .close {
      position: absolute;
      top: 30px;
      right: 45px;
      color: var(--text-color);
      font-size: 40px;
      font-weight: bold;
      transition: color 0.3s;
      cursor: pointer;
    }

    .close:hover,
    .close:focus {
      color: var(--accent-color);
      text-decoration: none;
      cursor: pointer;
    }

    @media only screen and (max-width: 700px){
      .modal-content {
        width: 100%;
      }

      .close {
        top: 15px;
        right: 35px;
        font-size: 30px;
      }
    }
  </style>
</head>
<body>
  <div class="main-wrapper">
    <!-- Sidebar for Chat and Prompt Generators -->
    <aside class="sidebar" aria-label="Sidebar Navigation">
      <h2>AI Prompt Generator</h2>
      <div class="input-group">
        <label>Generuoti Aprašymą:</label>
        <button class="generate-prompt tooltip" onclick="generateRandomPrompt('background')" aria-label="Generuoti aprašymą į foną">
          <i class="fas fa-lightbulb"></i> GENERUOTI Į FONĄ
          <span class="tooltiptext">Generuoti atsitiktinį aprašymą fonui</span>
        </button>
        <button class="generate-prompt tooltip" onclick="generateRandomPrompt('character')" aria-label="Generuoti aprašymą į personažą">
          <i class="fas fa-lightbulb"></i> GENERUOTI Į PERSONAŽĄ
          <span class="tooltiptext">Generuoti atsitiktinį aprašymą personažui</span>
        </button>
      </div>
      <!-- Library Button -->
      <div class="input-group">
        <button class="library-button tooltip" onclick="showLibrary()" aria-label="Atidaryti biblioteką">
          <i class="fas fa-images"></i> LIBRARY
          <span class="tooltiptext">Peržiūrėti sugeneruotus vaizdus</span>
        </button>
      </div>
      <!-- Chat Interface -->
      <h2>Hexacola Chat</h2>
      <div class="chat" id="chat" role="log" aria-live="polite">
        <!-- Chat messages will appear here -->
      </div>
      <div class="chat-input-group">
        <input type="text" id="chatInput" placeholder="Rašykite žinutę..." aria-label="Rašyti žinutę" />
        <button onclick="sendMessage()" aria-label="Siųsti žinutę">
          <i class="fas fa-paper-plane"></i> Siųsti
        </button>
      </div>
    </aside>

    <!-- Main Container for Image Generation and Enhanced Features -->
    <main class="container active" id="generatorContainer" aria-label="Image Generator">
      <div class="header">
        <h1>Hexacola AI Image Generator</h1>
      </div>
      <!-- Prompts Section -->
      <div class="input-group">
        <label for="backgroundPrompt">Background Description:</label>
        <textarea id="backgroundPrompt" placeholder="Pvz., Saulėlydis kalnuose, ramus ežeras..." aria-label="Fono aprašymas"></textarea>
      </div>
      <div class="input-group">
        <label for="characterPrompt">Character Description:</label>
        <textarea id="characterPrompt" placeholder="Pvz., Jaunas riteris su sidabru kruopelė..." aria-label="Personažo aprašymas"></textarea>
        <button type="button" id="addCharacterBtn" onclick="addCharacterDescription()" title="Pridėti papildomą personažo aprašymą" aria-label="Pridėti papildomą personažo aprašymą">+</button>
      </div>
      <div id="additionalCharacterDescriptions">
        <!-- Additional character descriptions will appear here -->
      </div>
      <div class="input-group">
        <label for="negativePrompt">Negative Prompt:</label>
        <textarea id="negativePrompt" placeholder="Nenoriu logotipo, iškraipyto stiliaus..." aria-label="Neigiamas aprašymas"></textarea>
      </div>
      
      <!-- Feature Toggles Section -->
      <div class="toggles" aria-label="Feature Toggles">
        <!-- Camera Features Toggle Group -->
        <div class="toggle-group">
          <label>Camera Features:</label>
          <div class="toggle-buttons" id="cameraFeaturesToggles" role="group" aria-label="Camera Features Toggles">
            <!-- Dynamically populated toggle buttons for camera features -->
          </div>
        </div>
        <!-- Color Schemes Toggle Group -->
        <div class="toggle-group">
          <label>Color Schemes:</label>
          <div class="toggle-buttons" id="colorSchemesToggles" role="group" aria-label="Color Schemes Toggles">
            <!-- Dynamically populated toggle buttons for color schemes -->
          </div>
        </div>
      </div>
      
      <!-- Dynamic Descriptions -->
      <div class="description" id="dynamicDescription" aria-live="polite">
        <!-- Descriptions for selected features and color schemes will appear here -->
      </div>
      
      <!-- Options -->
      <div class="input-group">
        <div class="option">
          <label for="model">Modelis:</label>
          <select id="model" aria-label="Pasirinkti modelį">
            <option value="flux" selected>Flux</option>
            <option value="flux-anime">Flux-Anime</option>
            <option value="flux-3d">Flux-3D</option>
            <option value="flux-pro">Flux-Pro</option>
            <option value="flux-realism">Flux-Realism</option>
            <option value="flux-cablyal">Flux-CablyAl</option>
            <option value="any-dark">Any-Dark</option>
            <option value="turbo">Turbo</option>
            <option value="Unity">Unity</option>
          </select>
        </div>
        <div class="option">
          <label for="width">Plotis (px):</label>
          <input type="number" id="width" value="512" min="64" max="2048" aria-label="Nustatyti plotį pikseliais" />
        </div>
        <div class="option">
          <label for="height">Aukštis (px):</label>
          <input type="number" id="height" value="512" min="64" max="2048" aria-label="Nustatyti aukštį pikseliais" />
        </div>
        <div class="option">
          <label for="seed">Seed:</label>
          <input type="number" id="seed" placeholder="Palikite tuščią..." aria-label="Nustatyti sėklą" />
        </div>
        <div class="option">
          <label for="imageOptions">Kiek paveikslėlių:</label>
          <input type="number" id="imageOptions" value="1" min="1" max="10" aria-label="Nustatyti paveikslėlių kiekį" />
        </div>
        <div class="option">
          <label for="style">Stilius:</label>
          <select id="style" aria-label="Pasirinkti stilių">
            <option value="None">None</option>
            <option value="Film">Film</option>
            <option value="Pixel Art">Pixel Art</option>
            <option value="Anime">Anime</option>
            <option value="Realistic">Realistic</option>
            <option value="Mix">Mix</option>
            <option value="Storyboard">Storyboard</option>
            <option value="Film Noir">Film Noir</option>
            <option value="Vintage">Vintage</option>
            <option value="Graphic Design">Graphic Design</option>
            <option value="Cartoon">Cartoon</option>
            <option value="Watercolor">Watercolor</option>
            <option value="Surrealism">Surrealism</option>
            <option value="Comics Style">Comics Style</option>
          </select>
        </div>
      </div>
      
      <!-- Buttons -->
      <div class="buttons">
        <button class="generate tooltip" onclick="generateImage()" aria-label="Generuoti vaizdą">
          <i class="fas fa-magic"></i> GENERUOTI
          <span class="tooltiptext">Spauskite norėdami sugeneruoti naują vaizdą</span>
        </button>
        <button class="auto-toggle tooltip" onclick="toggleAutoMode()" id="autoToggleBtn" data-tooltip="Automatiškai optimizuoja aprašymus naudojant AI" aria-pressed="false" aria-label="Automatinis režimas">
          <i class="fas fa-robot"></i> AUTO OFF
          <span class="tooltiptext">Automatiškai optimizuoja aprašymus naudojant AI</span>
        </button>
        <button class="dark-mode-toggle tooltip" onclick="toggleDarkMode()" aria-label="Perjungti tamsųjį režimą">
          <i class="fas fa-moon"></i> 🌙
          <span class="tooltiptext">Perjungti tarp tamsaus ir šviesaus režimo</span>
        </button>
      </div>
      
      <!-- Progress Bar -->
      <div class="progress-container" id="progressContainer" hidden aria-label="Generavimo progresas">
        <div class="progress-bar" id="progressBar"></div>
      </div>
      
      <!-- Generated Images -->
      <div class="generated-image" id="generatedImage" aria-label="Sugeneruoti vaizdai"></div>
      
      <!-- Loading Indicator -->
      <div class="overlay" id="overlay" role="dialog" aria-modal="true" aria-label="Generuojama">
        <div class="loader"></div>
        <div id="timer">Generuojama: 0s</div>
        <!-- Progress Bar -->
        <div class="progress-container" id="progressOverlay" hidden aria-label="Generavimo progresas">
          <div class="progress-bar" id="progressOverlayBar"></div>
        </div>
      </div>
    </main>

    <!-- Library Container -->
    <section class="library-container" id="libraryContainer" aria-label="Biblioteka">
      <h2>Library</h2>
      <div class="generated-image" id="libraryImages" aria-label="Bibliotekos vaizdai">
        <!-- Saved images will appear here -->
      </div>
      <div class="buttons">
        <button class="generate tooltip" onclick="showGenerator()" aria-label="Atgal į generatorių">
          <i class="fas fa-arrow-left"></i> GENERATOR
          <span class="tooltiptext">Grįžti į vaizdo generatorių</span>
        </button>
        <button class="download tooltip" onclick="downloadAllLibraryImages()" aria-label="Atsisiųsti visus vaizdus">
          <i class="fas fa-download"></i> ATSISIŲSTI VISKĄ
          <span class="tooltiptext">Atsisiųsti visus bibliotekos vaizdus</span>
        </button>
        <button class="clear-library tooltip" onclick="clearLibrary()" aria-label="Išvalyti biblioteką">
          <i class="fas fa-trash-alt"></i> IŠVALYTI LIBRARY
          <span class="tooltiptext">Išvalyti visus vaizdus iš bibliotekos</span>
        </button>
      </div>
    </section>
  </div>
  
  <!-- Modal for Fullscreen Image -->
  <div id="imageModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="modalImage">
    <span class="close" aria-label="Uždaryti">&times;</span>
    <img class="modal-content" id="modalImage" alt="Didelis sugeneruotas vaizdas">
  </div>

  <!-- Footer -->
  <footer>
    <p>
      API dokumentacija:
      <a href="https://github.com/pollinations/pollinations/blob/master/APIDOCS.md" target="_blank">Pollinations.AI GitHub</a>
    </p>
    <p>
      Sukurta su ❤️ naudojant
      <a href="https://pollinations.ai/" target="_blank">Pollinations.AI</a>.
    </p>
  </footer>

  <script>
    // JavaScript Code for Hexacola AI Image Generator

    // Global Variables
    let timerInterval;
    let autoMode = false;
    let totalImages = 0;
    let generatedImagesCount = 0;

    // Comprehensive List of Camera Features
    const cameraFeaturesList = [
      "DSLR",
      "Wide-angle lens",
      "Ultra-wide lens",
      "Telephoto lens",
      "Macro lens",
      "Fisheye lens",
      "Tilt-shift lens",
      "Pinhole camera",
      "360-degree panorama",
      "Satellite imagery",
      "Super-resolution microscopy",
      "Infrared photography",
      "Black-and-white film",
      "Vintage film camera",
      "Polaroid/instant camera",
      "Action camera (e.g., GoPro)",
      "Low-light/night photography lens",
      "Portrait lens (e.g., 85mm f/1.4)",
      "Large-format camera",
      "Medium-format camera",
      "Smartphone lens simulation",
      "Cinematic anamorphic lens",
      "Experimental lens effects (e.g., lens flare, kaleidoscope)"
    ];

    // Comprehensive List of Color Schemes based on Color Theory
    const colorSchemesList = [
      "Complementary",
      "Analogous",
      "Triadic",
      "Tetradic",
      "Split-Complementary",
      "Monochromatic"
    ];

    // Descriptions for Camera Features
    const cameraFeatureDescriptions = {
      "DSLR": "Digital Single-Lens Reflex cameras are known for their versatility, high image quality, and interchangeable lenses.",
      "Wide-angle lens": "A lens with a shorter focal length that captures a wider field of view than standard lenses.",
      "Ultra-wide lens": "A lens with an extremely wide field of view, ideal for capturing expansive landscapes and architecture.",
      "Telephoto lens": "A lens with a long focal length that allows photographers to capture distant subjects with magnification.",
      "Macro lens": "A lens designed for extreme close-up photography, allowing you to capture fine details of small subjects.",
      "Fisheye lens": "An ultra wide-angle lens that creates a spherical, distorted view, often used for creative and artistic photography.",
      "Tilt-shift lens": "A lens that allows for tilting and shifting to control the plane of focus and perspective distortion.",
      "Pinhole camera": "A simple camera without glass lenses, using a tiny aperture to create images with unique depth and focus characteristics.",
      "360-degree panorama": "A camera feature that allows capturing a full 360-degree panoramic view.",
      "Satellite imagery": "Images of Earth or other planets captured by satellites, used for mapping, weather forecasting, and more.",
      "Super-resolution microscopy": "Advanced microscopy techniques that surpass the diffraction limit to reveal finer details of specimens.",
      "Infrared photography": "Capturing images using infrared light, revealing details not visible to the naked eye.",
      "Black-and-white film": "Photography using monochromatic film, emphasizing contrast, texture, and composition.",
      "Vintage film camera": "Classic cameras known for their unique build and photographic characteristics, often used for nostalgic imagery.",
      "Polaroid/instant camera": "Cameras that produce instant prints, offering a tangible and immediate photographic experience.",
      "Action camera (e.g., GoPro)": "Compact and durable cameras designed for capturing action and adventure footage.",
      "Low-light/night photography lens": "Lenses optimized for capturing clear images in low-light or nighttime conditions.",
      "Portrait lens (e.g., 85mm f/1.4)": "Lenses with focal lengths ideal for capturing flattering portraits with shallow depth of field.",
      "Large-format camera": "Cameras that use large film or digital sensors, providing high resolution and detail.",
      "Medium-format camera": "Cameras that use medium-sized film or sensors, balancing quality and portability.",
      "Smartphone lens simulation": "Lens effects that mimic the capabilities of smartphone cameras, such as wide-angle and macro.",
      "Cinematic anamorphic lens": "Lenses that provide a wide aspect ratio and distinctive lens flares, used in filmmaking.",
      "Experimental lens effects (e.g., lens flare, kaleidoscope)": "Creative lens effects that add unique visual elements to images."
    };

    // Descriptions for Color Schemes
    const colorSchemeDescriptions = {
      "Complementary": "A color scheme using colors opposite each other on the color wheel, creating high contrast and vibrant look.",
      "Analogous": "A color scheme using colors next to each other on the color wheel, providing harmony and pleasing aesthetics.",
      "Triadic": "A color scheme using three colors evenly spaced around the color wheel, offering balanced and vibrant combinations.",
      "Tetradic": "A color scheme using four colors arranged into two complementary pairs, providing rich and varied color palettes.",
      "Split-Complementary": "A color scheme using one base color and two adjacent complementary colors, offering high contrast with less tension.",
      "Monochromatic": "A color scheme using variations in lightness and saturation of a single color, creating a cohesive and elegant look."
    };

    /**
     * Save settings to localStorage
     */
    function saveSettings() {
      const backgroundPrompt = document.getElementById('backgroundPrompt').value;
      const characterPrompt = document.getElementById('characterPrompt').value;
      const negativePrompt = document.getElementById('negativePrompt').value;
      const model = document.getElementById('model').value;
      const width = document.getElementById('width').value;
      const height = document.getElementById('height').value;
      const seed = document.getElementById('seed').value;
      const imageOptions = document.getElementById('imageOptions').value;
      const style = document.getElementById('style').value;

      // Collect additional character descriptions
      const additionalCharacterDescriptions = [];
      const additionalGroups = document.querySelectorAll('.additional-character-group textarea');
      additionalGroups.forEach(textarea => {
        const desc = textarea.value.trim();
        if (desc) {
          additionalCharacterDescriptions.push(desc);
        }
      });

      // Collect selected camera features
      const selectedCameraFeatures = Array.from(document.querySelectorAll('#cameraFeaturesToggles button.active')).map(btn => btn.textContent);

      // Collect selected color schemes
      const selectedColorSchemes = Array.from(document.querySelectorAll('#colorSchemesToggles button.active')).map(btn => btn.textContent);

      localStorage.setItem('backgroundPrompt', backgroundPrompt);
      localStorage.setItem('characterPrompt', characterPrompt);
      localStorage.setItem('negativePrompt', negativePrompt);
      localStorage.setItem('model', model);
      localStorage.setItem('width', width);
      localStorage.setItem('height', height);
      localStorage.setItem('seed', seed);
      localStorage.setItem('imageOptions', imageOptions);
      localStorage.setItem('style', style);
      localStorage.setItem('autoMode', autoMode);
      localStorage.setItem('additionalCharacterDescriptions', JSON.stringify(additionalCharacterDescriptions));
      localStorage.setItem('selectedCameraFeatures', JSON.stringify(selectedCameraFeatures));
      localStorage.setItem('selectedColorSchemes', JSON.stringify(selectedColorSchemes));
    }

    /**
     * Load settings from localStorage
     */
    function loadSettings() {
      const backgroundPrompt = localStorage.getItem('backgroundPrompt');
      const characterPrompt = localStorage.getItem('characterPrompt');
      const negativePrompt = localStorage.getItem('negativePrompt');
      const model = localStorage.getItem('model');
      const width = localStorage.getItem('width');
      const height = localStorage.getItem('height');
      const seed = localStorage.getItem('seed');
      const imageOptions = localStorage.getItem('imageOptions');
      const style = localStorage.getItem('style');
      const savedAutoMode = localStorage.getItem('autoMode');
      const additionalCharacterDescriptions = JSON.parse(localStorage.getItem('additionalCharacterDescriptions') || '[]');
      const selectedCameraFeatures = JSON.parse(localStorage.getItem('selectedCameraFeatures') || '[]');
      const selectedColorSchemes = JSON.parse(localStorage.getItem('selectedColorSchemes') || '[]');

      if (backgroundPrompt) document.getElementById('backgroundPrompt').value = backgroundPrompt;
      if (characterPrompt) document.getElementById('characterPrompt').value = characterPrompt;
      if (negativePrompt) document.getElementById('negativePrompt').value = negativePrompt;
      if (model) document.getElementById('model').value = model;
      if (width) document.getElementById('width').value = width;
      if (height) document.getElementById('height').value = height;
      if (seed) document.getElementById('seed').value = seed;
      if (imageOptions) document.getElementById('imageOptions').value = imageOptions;
      if (style) document.getElementById('style').value = style;

      if (savedAutoMode === 'true') {
        autoMode = true;
        document.getElementById('autoToggleBtn').classList.add('active');
        document.getElementById('autoToggleBtn').innerHTML = '<i class="fas fa-robot"></i> AUTO ON';
        document.getElementById('autoToggleBtn').setAttribute('aria-pressed', 'true');
      } else {
        autoMode = false;
        document.getElementById('autoToggleBtn').classList.remove('active');
        document.getElementById('autoToggleBtn').innerHTML = '<i class="fas fa-robot"></i> AUTO OFF';
        document.getElementById('autoToggleBtn').setAttribute('aria-pressed', 'false');
      }

      // Load additional character descriptions
      additionalCharacterDescriptions.forEach(desc => {
        addCharacterDescription(desc);
      });

      // Load selected camera features
      selectedCameraFeatures.forEach(feature => {
        toggleFeature('cameraFeaturesToggles', feature);
      });

      // Load selected color schemes
      selectedColorSchemes.forEach(scheme => {
        toggleFeature('colorSchemesToggles', scheme);
      });

      // Update dynamic descriptions
      updateDynamicDescription();
    }

    /**
     * Initial load and setup
     */
    document.addEventListener('DOMContentLoaded', () => {
      populateCameraFeatureToggles();
      populateColorSchemeToggles();
      loadSettings();
      loadDarkMode();
      setupModal();
      initializeNegativePrompt();
      loadLibraryImages();
      disableImageDownload();
    });

    /**
     * Populate Camera Features Toggles
     */
    function populateCameraFeatureToggles() {
      const container = document.getElementById('cameraFeaturesToggles');
      cameraFeaturesList.forEach(feature => {
        const btn = document.createElement('button');
        btn.textContent = feature;
        btn.setAttribute('aria-pressed', 'false');
        btn.setAttribute('aria-label', feature);
        btn.onclick = () => {
          btn.classList.toggle('active');
          btn.setAttribute('aria-pressed', btn.classList.contains('active'));
          updateDynamicDescription();
          saveSettings();
        };
        container.appendChild(btn);
      });
    }

    /**
     * Populate Color Schemes Toggles
     */
    function populateColorSchemeToggles() {
      const container = document.getElementById('colorSchemesToggles');
      colorSchemesList.forEach(scheme => {
        const btn = document.createElement('button');
        btn.textContent = scheme;
        btn.setAttribute('aria-pressed', 'false');
        btn.setAttribute('aria-label', scheme);
        btn.onclick = () => {
          btn.classList.toggle('active');
          btn.setAttribute('aria-pressed', btn.classList.contains('active'));
          updateDynamicDescription();
          saveSettings();
        };
        container.appendChild(btn);
      });
    }

    /**
     * Toggle feature in a specific toggle group
     * @param {string} groupId - ID of the toggle group
     * @param {string} feature - Feature name to toggle
     */
    function toggleFeature(groupId, feature) {
      const container = document.getElementById(groupId);
      const button = Array.from(container.children).find(btn => btn.textContent === feature);
      if (button && !button.classList.contains('active')) {
        button.classList.add('active');
        button.setAttribute('aria-pressed', 'true');
      }
    }

    /**
     * Update Dynamic Description based on selected toggles
     */
    function updateDynamicDescription() {
      const selectedCameraFeatures = Array.from(document.querySelectorAll('#cameraFeaturesToggles button.active')).map(btn => btn.textContent);
      const selectedColorSchemes = Array.from(document.querySelectorAll('#colorSchemesToggles button.active')).map(btn => btn.textContent);
      let description = '';

      if (selectedCameraFeatures.length > 0) {
        description += `<strong>Camera Features:</strong> ${selectedCameraFeatures.join(', ')}<br>`;
      }

      if (selectedColorSchemes.length > 0) {
        description += `<strong>Color Schemes:</strong> ${selectedColorSchemes.join(', ')}<br>`;
      }

      // Include additional character descriptions
      const additionalGroups = document.querySelectorAll('.additional-character-group textarea');
      if (additionalGroups.length > 0) {
        let additionalDescriptions = [];
        additionalGroups.forEach(textarea => {
          const desc = textarea.value.trim();
          if (desc) {
            additionalDescriptions.push(desc);
          }
        });
        if (additionalDescriptions.length > 0) {
          description += `<strong>Additional Character Descriptions:</strong> ${additionalDescriptions.join('; ')}<br>`;
        }
      }

      document.getElementById('dynamicDescription').innerHTML = description;
    }

    /**
     * Dark Mode Toggle
     */
    function toggleDarkMode() {
      document.body.classList.toggle('dark-mode');
      const toggleBtn = document.querySelector('.dark-mode-toggle');
      if (document.body.classList.contains('dark-mode')) {
        toggleBtn.innerHTML = '<i class="fas fa-sun"></i> ☀️';
        toggleBtn.setAttribute('aria-label', 'Perjungti į šviesų režimą');
        toggleBtn.setAttribute('aria-pressed', 'true');
      } else {
        toggleBtn.innerHTML = '<i class="fas fa-moon"></i> 🌙';
        toggleBtn.setAttribute('aria-label', 'Perjungti į tamsųjį režimą');
        toggleBtn.setAttribute('aria-pressed', 'false');
      }
      localStorage.setItem('darkMode', document.body.classList.contains('dark-mode'));
    }

    /**
     * Load Dark Mode settings
     */
    function loadDarkMode() {
      const darkMode = localStorage.getItem('darkMode');
      if (darkMode === 'true') {
        document.body.classList.add('dark-mode');
        const toggleBtn = document.querySelector('.dark-mode-toggle');
        toggleBtn.innerHTML = '<i class="fas fa-sun"></i> ☀️';
        toggleBtn.setAttribute('aria-label', 'Perjungti į šviesų režimą');
        toggleBtn.setAttribute('aria-pressed', 'true');
      } else {
        const toggleBtn = document.querySelector('.dark-mode-toggle');
        toggleBtn.innerHTML = '<i class="fas fa-moon"></i> 🌙';
        toggleBtn.setAttribute('aria-label', 'Perjungti į tamsųjį režimą');
        toggleBtn.setAttribute('aria-pressed', 'false');
      }
    }

    /**
     * Auto Mode Toggle
     */
    function toggleAutoMode() {
      autoMode = !autoMode;
      const toggleBtn = document.getElementById('autoToggleBtn');
      if (autoMode) {
        toggleBtn.classList.add('active');
        toggleBtn.innerHTML = '<i class="fas fa-robot"></i> AUTO ON';
        toggleBtn.setAttribute('aria-pressed', 'true');
      } else {
        toggleBtn.classList.remove('active');
        toggleBtn.innerHTML = '<i class="fas fa-robot"></i> AUTO OFF';
        toggleBtn.setAttribute('aria-pressed', 'false');
      }
      localStorage.setItem('autoMode', autoMode);
    }

    /**
     * Add Additional Character Description
     * @param {string} description - Optional pre-filled description
     */
    function addCharacterDescription(description = '') {
      const container = document.getElementById('additionalCharacterDescriptions');
      
      const descriptionCount = container.children.length;
      if (descriptionCount >= 5) { // Limit to 5 additional descriptions
        alert('Galite pridėti iki 5 papildomų personažo aprašymų.');
        return;
      }

      const newGroup = document.createElement('div');
      newGroup.classList.add('input-group', 'additional-character-group');

      const label = document.createElement('label');
      label.textContent = `Additional Character Description ${descriptionCount + 1}:`;
      label.setAttribute('for', `additionalCharacterPrompt${descriptionCount + 1}`);

      const textarea = document.createElement('textarea');
      textarea.id = `additionalCharacterPrompt${descriptionCount + 1}`;
      textarea.placeholder = 'Pvz., ilgasis šaknys, puikiai sutvarkyta šviesa...';
      textarea.value = description;
      textarea.setAttribute('aria-label', `Additional Character Description ${descriptionCount + 1}`);
      textarea.oninput = updateDynamicDescription;

      const removeBtn = document.createElement('button');
      removeBtn.type = 'button';
      removeBtn.textContent = '–'; // Remove button
      removeBtn.title = 'Pašalinti šį aprašymą';
      removeBtn.setAttribute('aria-label', 'Pašalinti šį aprašymą');
      removeBtn.onclick = () => {
        container.removeChild(newGroup);
        updateDynamicDescription();
        saveSettings(); // Save changes
      };

      newGroup.appendChild(label);
      newGroup.appendChild(textarea);
      newGroup.appendChild(removeBtn);

      container.appendChild(newGroup);
      updateDynamicDescription();
    }

    /**
     * Show Library
     */
    function showLibrary() {
      document.getElementById('generatorContainer').classList.remove('active');
      document.getElementById('libraryContainer').classList.add('active');
      disableImageDownload(); // Ensure new images have download disabled
    }

    /**
     * Show Generator
     */
    function showGenerator() {
      document.getElementById('libraryContainer').classList.remove('active');
      document.getElementById('generatorContainer').classList.add('active');
      disableImageDownload(); // Ensure new images have download disabled
    }

    /**
     * Add Image to Library Gallery
     * @param {string} url - Image URL
     * @param {string} prompt - Image prompt
     * @param {string} model - Model used
     * @param {string} width - Image width
     * @param {string} height - Image height
     * @param {string|number} seed - Seed used
     * @param {string} mimeType - Image MIME type
     */
    function addImageToLibraryGallery(url, prompt, model, width, height, seed, mimeType) {
      const libraryImagesDiv = document.getElementById('libraryImages');
      const imageContainer = document.createElement('div');
      imageContainer.classList.add('image-container');

      const imgElement = document.createElement('img');
      imgElement.src = url;
      imgElement.alt = 'Sugeneruotas vaizdas';
      imgElement.title = 'Spauskite norėdami padidinti';
      imgElement.dataset.type = mimeType; // Store MIME type for correct file extension
      imageContainer.appendChild(imgElement);

      // Add caption
      const caption = document.createElement('div');
      caption.classList.add('caption');
      caption.innerHTML = `
        <strong>Prompt:</strong> ${sanitizeHTML(prompt)}<br>
        <strong>Model:</strong> ${sanitizeHTML(model)}<br>
        <strong>Dimensions:</strong> ${sanitizeHTML(width)}px x ${sanitizeHTML(height)}px<br>
        <strong>Seed:</strong> ${sanitizeHTML(seed)}
      `;
      imageContainer.appendChild(caption);

      // Add download options
      const downloadOptions = document.createElement('div');
      downloadOptions.classList.add('download-options');

      const formatSelect = document.createElement('select');
      formatSelect.innerHTML = `
        <option value="png">PNG</option>
        <option value="jpg">JPG</option>
        <option value="webp">WEBP</option>
      `;
      downloadOptions.appendChild(formatSelect);

      const downloadBtn = document.createElement('button');
      downloadBtn.innerHTML = '<i class="fas fa-download"></i> Download';
      downloadBtn.setAttribute('aria-label', 'Atsisiųsti vaizdą');
      downloadBtn.onclick = () => {
        const format = formatSelect.value;
        downloadImage(url, `hexacola_image_${sanitizeFileName(seed)}.${format}`, format);
      };
      downloadOptions.appendChild(downloadBtn);

      imageContainer.appendChild(downloadOptions);

      libraryImagesDiv.appendChild(imageContainer);
    }

    /**
     * Download Image in Selected Format
     * @param {string} url - Image URL
     * @param {string} filename - Desired filename
     * @param {string} format - Image format
     */
    async function downloadImage(url, filename, format) {
      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error('Nepavyko atsisiųsti vaizdo.');
        const blob = await response.blob();
        let convertedBlob = blob;

        if (format !== blob.type.split('/')[1]) {
          const imageBitmap = await createImageBitmap(blob);
          const canvas = document.createElement('canvas');
          canvas.width = imageBitmap.width;
          canvas.height = imageBitmap.height;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(imageBitmap, 0, 0);
          convertedBlob = await new Promise(resolve => canvas.toBlob(resolve, `image/${format}`));
          if (!convertedBlob) throw new Error('Nepavyko konvertuoti vaizdo formato.');
        }

        const a = document.createElement('a');
        a.href = URL.createObjectURL(convertedBlob);
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href); // Revoke the object URL after download
      } catch (error) {
        console.error('Atsisiuntimo klaida:', error);
        alert('Klaida atsisiunčiant vaizdą. Bandykite dar kartą.');
      }
    }

    /**
     * Sanitize HTML to prevent XSS
     * @param {string} str - Input string
     * @returns {string} - Sanitized string
     */
    function sanitizeHTML(str) {
      const temp = document.createElement('div');
      temp.textContent = str;
      return temp.innerHTML;
    }

    /**
     * Sanitize File Name
     * @param {string|number} seed - Seed used
     * @returns {string} - Sanitized file name
     */
    function sanitizeFileName(seed) {
      return String(seed).replace(/[^a-z0-9]/gi, '_').toLowerCase();
    }

    /**
     * Load Library Images from localStorage
     */
    function loadLibraryImages() {
      let images = JSON.parse(localStorage.getItem('generatedImages')) || [];
      images.forEach(image => {
        addImageToLibraryGallery(image.url, image.prompt, image.model, image.width, image.height, image.seed, image.mimeType);
      });
    }

    /**
     * Clear Library
     */
    function clearLibrary() {
      if (confirm('Ar tikrai norite išvalyti visus vaizdus iš bibliotekos?')) {
        localStorage.removeItem('generatedImages');
        document.getElementById('libraryImages').innerHTML = '';
        alert('Library sėkmingai išvalyta.');
      }
    }

    /**
     * Generate Image
     */
    async function generateImage() {
      const generateButton = document.querySelector('.generate');
      generateButton.disabled = true; // Disable button during generation

      const backgroundPrompt = document.getElementById('backgroundPrompt').value.trim();
      const characterPrompt = document.getElementById('characterPrompt').value.trim();
      const negativePrompt = document.getElementById('negativePrompt').value.trim();
      const model = document.getElementById('model').value;
      const width = parseInt(document.getElementById('width').value, 10);
      const height = parseInt(document.getElementById('height').value, 10);
      const seedInput = document.getElementById('seed').value.trim();
      const seed = seedInput ? parseInt(seedInput, 10) : null;
      const imageOptions = parseInt(document.getElementById('imageOptions').value, 10);
      const style = document.getElementById('style').value;

      // Collect additional character descriptions
      const additionalCharacterDescriptions = [];
      const additionalGroups = document.querySelectorAll('.additional-character-group textarea');
      additionalGroups.forEach(textarea => {
        const desc = textarea.value.trim();
        if (desc) {
          additionalCharacterDescriptions.push(desc);
        }
      });

      // Collect selected camera features
      const selectedCameraFeatures = Array.from(document.querySelectorAll('#cameraFeaturesToggles button.active')).map(btn => btn.textContent);

      // Collect selected color schemes
      const selectedColorSchemes = Array.from(document.querySelectorAll('#colorSchemesToggles button.active')).map(btn => btn.textContent);

      // Check if no prompts are provided
      const noPrompts = !backgroundPrompt && !characterPrompt && additionalCharacterDescriptions.length === 0;

      let backgroundCombinedPrompt = '';
      let characterCombinedPrompt = '';

      if (noPrompts) {
        // Generate both background and character prompts if none provided
        try {
          [backgroundCombinedPrompt, characterCombinedPrompt] = await Promise.all([
            generateRandomPromptFunction('background', style, selectedCameraFeatures, selectedColorSchemes),
            generateRandomPromptFunction('character', style, selectedCameraFeatures, selectedColorSchemes)
          ]);
          // Assign generated prompts
          document.getElementById('backgroundPrompt').value = backgroundCombinedPrompt;
          document.getElementById('characterPrompt').value = characterCombinedPrompt;
        } catch (error) {
          console.error(error);
          alert('Nepavyko sugeneruoti atsitiktinio aprašymo. Bandykite dar kartą.');
          generateButton.disabled = false;
          return;
        }
      } else {
        // If at least one prompt is provided, use them as is
        backgroundCombinedPrompt = backgroundPrompt;
        characterCombinedPrompt = characterPrompt;
      }

      // Ensure at least one prompt is present
      if ((!backgroundCombinedPrompt && !characterCombinedPrompt)) {
        alert('Prašome įvesti bent vieną fono arba personažo aprašymą.');
        generateButton.disabled = false;
        return;
      }

      saveSettings();

      let optimizedBackgroundPrompt = backgroundCombinedPrompt;
      let optimizedCharacterPrompt = characterCombinedPrompt;
      let optimizedNegativePrompt = "low quality, blurry, bad anatomy, out of focus, noise, duplicate, watermark, text, ugly, messy, " + negativePrompt;

      if (autoMode) {
        try {
          // Optimize background prompt with style, camera features, and color schemes
          if (backgroundCombinedPrompt) {
            optimizedBackgroundPrompt = await optimizePrompt(`Optimize the following background prompt for high-quality image generation in ${style} style with camera features ${selectedCameraFeatures.join(', ')} and color schemes ${selectedColorSchemes.join(', ')}: "${backgroundCombinedPrompt}"`);
          }

          // Optimize character prompt with style, camera features, and color schemes
          if (characterCombinedPrompt) {
            optimizedCharacterPrompt = await optimizePrompt(`Optimize the following character prompt for high-quality image generation in ${style} style with camera features ${selectedCameraFeatures.join(', ')} and color schemes ${selectedColorSchemes.join(', ')}: "${characterCombinedPrompt}"`);
          }

          // Optimize each additional character description
          for (let i = 0; i < additionalCharacterDescriptions.length; i++) {
            additionalCharacterDescriptions[i] = await optimizePrompt(`Optimize the following character description to match the ${style} style with camera features ${selectedCameraFeatures.join(', ')} and color schemes ${selectedColorSchemes.join(', ')}: "${additionalCharacterDescriptions[i]}"`);
          }

          // Optimize negative prompt
          if (negativePrompt) {
            optimizedNegativePrompt = "low quality, blurry, bad anatomy, out of focus, noise, duplicate, watermark, text, ugly, messy, " + await optimizePrompt(`Optimize the following negative prompt to exclude unwanted elements: "${negativePrompt}"`);
          }
        } catch (error) {
          console.error(error);
          alert('Klaida optimizuojant aprašymus su AI. Bandykite dar kartą.');
          generateButton.disabled = false;
          return;
        }
      }

      // Integrate additional character descriptions
      let fullCharacterPrompt = optimizedCharacterPrompt;
      if (additionalCharacterDescriptions.length > 0) {
        fullCharacterPrompt += ' ' + additionalCharacterDescriptions.join(' ');
        fullCharacterPrompt += ' Ensure that all characters maintain the same style, face structure, and clothing as described above.';
      }

      // Integrate camera features and color schemes into the combined prompt
      let combinedPrompt = '';
      if (optimizedBackgroundPrompt && fullCharacterPrompt) {
        combinedPrompt = `${optimizedBackgroundPrompt}, ${fullCharacterPrompt}, with correct proportions, good perspective, and excellent composition.`;
      } else if (optimizedBackgroundPrompt) {
        combinedPrompt = `${optimizedBackgroundPrompt}, with correct proportions, good perspective, and excellent composition.`;
      } else if (fullCharacterPrompt) {
        combinedPrompt = `${fullCharacterPrompt}, with correct proportions, good perspective, and excellent composition.`;
      }

      // Append style
      if (style === 'Mix') {
        combinedPrompt = appendMixStyleToPrompt(combinedPrompt);
      } else if (style !== 'None') {
        combinedPrompt = appendStyleToPrompt(combinedPrompt, style);
      }

      // Append camera features and color schemes descriptions at the beginning for top priority
      if (selectedCameraFeatures.length > 0) {
        combinedPrompt = `${selectedCameraFeatures.join(', ')}, ${combinedPrompt}`;
      }
      if (selectedColorSchemes.length > 0) {
        combinedPrompt = `${selectedColorSchemes.join(', ')}, ${combinedPrompt}`;
      }

      // Create API URL
      let urlBase = `https://image.pollinations.ai/prompt/${encodeURIComponent(combinedPrompt)}?model=${encodeURIComponent(model)}&width=${encodeURIComponent(width)}&height=${encodeURIComponent(height)}&nologo=true`;

      // Remove 'negative' parameter as it's not part of the API specification
      // If you have a different method to handle negative prompts, implement it accordingly
      // For now, we will exclude the negative prompt from the URL

      try {
        // Show loading overlay and start timer
        const overlay = document.getElementById('overlay');
        const timer = document.getElementById('timer');
        const progressOverlay = document.getElementById('progressOverlay');
        const progressOverlayBar = document.getElementById('progressOverlayBar');
        overlay.style.display = 'flex';
        progressOverlay.style.display = 'block';
        let seconds = 0;
        timer.textContent = `Generuojama: ${seconds}s`;
        timerInterval = setInterval(() => {
          seconds++;
          timer.textContent = `Generuojama: ${seconds}s`;
        }, 1000);

        // Initialize progress bar
        totalImages = imageOptions;
        generatedImagesCount = 0;
        updateProgressBar();

        // Clear previous generated images
        const generatedImageDiv = document.getElementById('generatedImage');
        generatedImageDiv.innerHTML = '';

        // Generate images concurrently with unique seeds
        const promises = [];
        for (let i = 0; i < imageOptions; i++) {
          let uniqueSeed;
          if (seed) {
            uniqueSeed = seed + i; // Increment seed
          } else {
            uniqueSeed = Math.floor(Math.random() * 100000); // Random seed
          }
          const url = `${urlBase}&seed=${encodeURIComponent(uniqueSeed)}`;
          promises.push(fetch(url).then(response => {
            if (!response.ok) {
              throw new Error('Nepavyko sugeneruoti vaizdo.');
            }
            return response.blob();
          }).catch(error => {
            console.error(`Vaizdo generavimo klaida (Seed: ${uniqueSeed}):`, error);
            return null;
          }));
        }

        const blobs = await Promise.all(promises);
        blobs.forEach((blob, index) => {
          if (blob) {
            const imgUrl = URL.createObjectURL(blob);
            const imageContainer = document.createElement('div');
            imageContainer.classList.add('image-container');

            const imgElement = document.createElement('img');
            imgElement.src = imgUrl;
            imgElement.alt = 'Sugeneruotas vaizdas';
            imgElement.title = 'Spauskite norėdami padidinti';
            imgElement.dataset.type = blob.type; // Store MIME type
            imageContainer.appendChild(imgElement);

            // Add caption
            const caption = document.createElement('div');
            caption.classList.add('caption');
            caption.innerHTML = `
              <strong>Prompt:</strong> ${sanitizeHTML(combinedPrompt)}<br>
              <strong>Model:</strong> ${sanitizeHTML(model)}<br>
              <strong>Dimensions:</strong> ${sanitizeHTML(width)}px x ${sanitizeHTML(height)}px<br>
              <strong>Seed:</strong> ${sanitizeHTML(seed ? uniqueSeed : 'Random')}
            `;
            imageContainer.appendChild(caption);

            // Add download options
            const downloadOptions = document.createElement('div');
            downloadOptions.classList.add('download-options');

            const formatSelect = document.createElement('select');
            formatSelect.innerHTML = `
              <option value="png">PNG</option>
              <option value="jpg">JPG</option>
              <option value="webp">WEBP</option>
            `;
            downloadOptions.appendChild(formatSelect);

            const downloadBtn = document.createElement('button');
            downloadBtn.innerHTML = '<i class="fas fa-download"></i> Download';
            downloadBtn.setAttribute('aria-label', 'Atsisiųsti vaizdą');
            downloadBtn.onclick = () => {
              const format = formatSelect.value;
              downloadImage(imgUrl, `hexacola_image_${sanitizeFileName(seed ? uniqueSeed : index + 1)}.${format}`, format);
            };
            downloadOptions.appendChild(downloadBtn);

            imageContainer.appendChild(downloadOptions);

            generatedImageDiv.appendChild(imageContainer);

            // Save image to localStorage and add to library
            saveImage(imgUrl, combinedPrompt, model, width, height, seed ? uniqueSeed : `Random_${Date.now()}`, blob.type);
            addImageToLibraryGallery(imgUrl, combinedPrompt, model, width, height, seed ? uniqueSeed : `Random_${Date.now()}`, blob.type);

            // Update progress bar
            generatedImagesCount++;
            updateProgressBar();
          } else {
            // Even if image generation failed, update progress
            generatedImagesCount++;
            updateProgressBar();
          }
        });
      } catch (error) {
        console.error(error);
        alert('Klaida generuojant vaizdą. Bandykite dar kartą.');
        document.getElementById('generatedImage').innerHTML = '';
      } finally {
        // Hide loading overlay and stop timer
        document.getElementById('overlay').style.display = 'none';
        clearInterval(timerInterval);
        generateButton.disabled = false;
        document.getElementById('progressOverlay').style.display = 'none';
        disableImageDownload();
      }
    }

    /**
     * Download All Library Images
     */
    async function downloadAllLibraryImages() {
      const images = document.querySelectorAll('#libraryImages img');
      if (images.length === 0) {
        alert('Nėra vaizdų atsisiuntimui.');
        return;
      }
      for (let i = 0; i < images.length; i++) {
        const img = images[i];
        const mimeType = img.dataset.type || 'image/png'; // Default to png if type not found
        const extension = mimeType.split('/')[1] || 'png';
        const seed = img.parentElement.querySelector('.caption strong:nth-child(4)').nextSibling.textContent.trim();
        const filename = `hexacola_image_${sanitizeFileName(seed)}.${extension}`;
        await downloadImage(img.src, filename, extension);
      }
    }

    /**
     * Update Progress Bar
     */
    function updateProgressBar() {
      const progressBar = document.getElementById('progressOverlayBar');
      const progressPercentage = (generatedImagesCount / totalImages) * 100;
      progressBar.style.width = `${progressPercentage}%`;
      if (progressPercentage >= 100) {
        progressBar.style.backgroundColor = '#4caf50'; // Green when complete
      }
    }

    /**
     * Optimize Prompt using Pollinations.AI API
     * @param {string} prompt - Prompt to optimize
     * @returns {string} - Optimized prompt
     */
    async function optimizePrompt(prompt) {
      const response = await fetch('https://text.pollinations.ai/openai', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          messages: [
            { role: 'system', content: 'Tu esi Hexacola GPT – kūrybingas ir universalus AI įrankis, skirtas generuoti aukštos kokybės promptus ir vaizdus, optimizuotus su Pollinations.AI. Tavo specializacija – kurti unikalius personažų aprašymus, įtraukiančius pasaulių fonus (backgrounds), detalizuotus scenarijus ir stilingus vaizdinius aprašymus, kurie puikiai dera su Pollinations.AI vaizdų generavimo galimybėmis. Tu atsižvelgi į stilistiką, spalvų paletę, kompoziciją ir vartotojo pageidavimus, siekdamas išlaikyti geriausią vaizdo ir teksto kokybę. Tu visada sieki kokybiškų nuotraukų ir vaizdų, atsižvelgiant į detalumą ir estetiką. Tavo tikslas – pateikti įkvepiančius ir estetiškai harmoningus rezultatus, pritaikomus literatūrai, žaidimų dizainui, audiovizualiniams projektams ir kūrybinei saviraiškai.' },
            { role: 'user', content: prompt }
          ],
          model: 'openai', // Pollinations.AI default model
          seed: Math.floor(Math.random() * 100000),
          jsonMode: false
        }),
      });

      if (!response.ok) {
        throw new Error('Nepavyko susisiekti su AI paslauga.');
      }

      const data = await response.json();
      if (data.choices && data.choices.length > 0 && data.choices[0].message) {
        const optimizedPrompt = data.choices[0].message.content;
        return optimizedPrompt.trim();
      } else {
        throw new Error('Neteisingas AI atsakymas.');
      }
    }

    /**
     * Generate Random Prompt Function
     * @param {string} target - 'background' or 'character'
     * @param {string} style - Selected style
     * @param {Array} cameraFeatures - Selected camera features
     * @param {Array} colorSchemes - Selected color schemes
     * @returns {string} - Generated prompt
     */
    async function generateRandomPromptFunction(target, style, cameraFeatures, colorSchemes) {
      let basePrompt = '';
      if (target === 'background') {
        basePrompt = 'Generate a creative and detailed description for a background of an AI-generated image that is unique and visually appealing. Ensure it is suitable for a high-quality image generation with appropriate style adaptations.';
      } else if (target === 'character') {
        basePrompt = 'Generate a creative and detailed description for a character of an AI-generated image that is unique and visually appealing. Ensure it is suitable for a high-quality image generation with appropriate style adaptations.';
      } else {
        throw new Error('Invalid target for prompt generation.');
      }

      // Integrate camera features and color schemes for top priority
      let enhancedPrompt = '';
      if (cameraFeatures.length > 0) {
        enhancedPrompt += `${cameraFeatures.join(', ')}, `;
      }
      if (colorSchemes.length > 0) {
        enhancedPrompt += `${colorSchemes.join(', ')}, `;
      }
      enhancedPrompt += basePrompt;

      const response = await fetch('https://text.pollinations.ai/openai', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          messages: [
            { role: 'system', content: 'Tu esi Hexacola GPT – kūrybingas ir universalus AI įrankis, skirtas generuoti aukštos kokybės promptus ir vaizdus, optimizuotus su Pollinations.AI. Tavo specializacija – kurti unikalius personažų aprašymus, įtraukiančius pasaulių fonus (backgrounds), detalizuotus scenarijus ir stilingus vaizdinius aprašymus, kurie puikiai dera su Pollinations.AI vaizdų generavimo galimybėmis. Tu atsižvelgi į stilistiką, spalvų paletę, kompoziciją ir vartotojo pageidavimus, siekdamas išlaikyti geriausią vaizdo ir teksto kokybę. Tu visada sieki kokybiškų nuotraukų ir vaizdų, atsižvelgiant į detalumą ir estetiką. Tavo tikslas – pateikti įkvepiančius ir estetiškai harmoningus rezultatus, pritaikomus literatūrai, žaidimų dizainui, audiovizualiniams projektams ir kūrybinei saviraiškai.' },
            { role: 'user', content: enhancedPrompt }
          ],
          model: 'openai', // Pollinations.AI default model
          seed: Math.floor(Math.random() * 100000),
          jsonMode: false
        }),
      });

      if (!response.ok) {
        throw new Error('Nepavyko susisiekti su AI paslauga.');
      }

      const data = await response.json();
      if (data.choices && data.choices.length > 0 && data.choices[0].message) {
        let generatedPrompt = data.choices[0].message.content;
        generatedPrompt = generatedPrompt.trim();

        // Apply style if selected
        if (style && style !== 'None') {
          generatedPrompt = appendStyleToPrompt(generatedPrompt, style);
        }

        return generatedPrompt;
      } else {
        throw new Error('Neteisingas AI atsakymas.');
      }
    }

    /**
     * Generate Random Prompt
     * @param {string} target - 'background' or 'character'
     */
    async function generateRandomPrompt(target) {
      const style = document.getElementById('style').value;
      const selectedCameraFeatures = Array.from(document.querySelectorAll('#cameraFeaturesToggles button.active')).map(btn => btn.textContent);
      const selectedColorSchemes = Array.from(document.querySelectorAll('#colorSchemesToggles button.active')).map(btn => btn.textContent);
      const generateButtons = document.querySelectorAll('.generate-prompt');
      generateButtons.forEach(button => button.disabled = true); // Disable all prompt buttons during generation

      try {
        const prompt = await generateRandomPromptFunction(target, style, selectedCameraFeatures, selectedColorSchemes);
        if (target === 'background') {
          document.getElementById('backgroundPrompt').value = prompt;
        } else if (target === 'character') {
          document.getElementById('characterPrompt').value = prompt;
        }
        alert(`Sėkmingai sugeneruotas ${target} aprašymas!`);
      } catch (error) {
        console.error(error);
        alert('Klaida generuojant aprašymą. Bandykite dar kartą.');
      } finally {
        generateButtons.forEach(button => button.disabled = false); // Re-enable buttons after generation
      }
    }

    /**
     * Append Style to Prompt
     * @param {string} prompt - Original prompt
     * @param {string} style - Selected style
     * @returns {string} - Prompt with appended style
     */
    function appendStyleToPrompt(prompt, style) {
      const styleDescriptions = {
        'Film': `${prompt}, cinematic masterpiece, shot with an anamorphic 35mm lens, ultra-wide aspect ratio, natural film grain, rich and moody cinematic color palette, deep contrast, dynamic range, soft and detailed lighting, natural bokeh, shallow depth of field, evocative storytelling, authentic vintage film aesthetics, timeless Hollywood style`,
        'Pixel Art': `${prompt}, in classic pixel art style, inspired by retro games like Final Fantasy and Chrono Trigger, 16-bit aesthetic, carefully crafted pixel details, balanced color palette, nostalgic and vibrant tones, smooth shading, and authentic retro charm`,
        'Anime': `${prompt}, in anime style inspired by classics like Attack on Titan and Demon Slayer, vivid and dynamic compositions, vibrant yet harmonious color schemes, expressive and detailed character designs, dramatic lighting, intricate line work, fluid motion elements, and a cinematic anime atmosphere`,
        'Realistic': `${prompt}, in hyper-realistic style, photorealistic details, meticulously rendered textures, lifelike proportions, dynamic and natural lighting, realistic depth of field, authentic environments, nuanced color grading, and true-to-life materials`,
        'Storyboard': `${prompt}, in hand-drawn black-and-white storyboard style, rough pencil sketch aesthetic, emphasizing composition, perspective, and dynamic camera angles, clear character blocking, cinematic framing, sequential flow, and annotations for action and dialogue cues`,
        'Film Noir': `${prompt}, in classic film noir style, high contrast black-and-white imagery, dramatic chiaroscuro lighting, deep shadows, atmospheric fog, urban backdrops, vintage aesthetics, fedoras and trench coats, suspenseful mood, and intense character expressions`,
        'Vintage': `${prompt}, in vintage style, muted and earthy color palette, soft film grain, faded textures, timeless composition, delicate vignetting, nostalgic atmosphere, classic typography, and retro-inspired design elements`,
        'Graphic Design': `${prompt}, in modern graphic design style, clean and balanced layouts, bold typography, striking color palettes, geometric shapes, high contrast, minimalist aesthetics, layered compositions, and visually compelling visuals tailored for branding or digital media`,
        'Cartoon': `${prompt}, in Cartoon Network-inspired style, bold and dynamic outlines, exaggerated yet balanced proportions, quirky character designs, vibrant and contrasting color palettes, playful and expressive animations, simplified but impactful backgrounds, lighthearted tone, and a touch of surreal humor reminiscent of shows like Adventure Time, The Amazing World of Gumball, and Dexter's Laboratory`,
        'Watercolor': `${prompt}, in delicate watercolor painting style, soft brush strokes, pastel and muted tones, organic textures, flowing gradients, and a dreamy, artistic atmosphere reminiscent of classic hand-painted illustrations`,
        'Surrealism': `${prompt}, in surreal style, dreamlike imagery, abstract forms, unconventional compositions, and a blend of reality and imagination, reminiscent of Salvador Dalí's artworks`,
        'Comics Style': `${prompt}, in vibrant comics style, bold black outlines, dynamic panel compositions, expressive character poses, exaggerated proportions, halftone patterns, action-packed scenes, vibrant primary colors, dramatic speech bubbles, and a storytelling aesthetic reminiscent of Marvel and DC classics`,
        'Mix': appendMixStyleToPrompt(prompt)
      };
      return styleDescriptions[style] || prompt;
    }

    /**
     * Get Random Styles for Mix
     * @returns {string} - Two different random styles
     */
    function getRandomStyles() {
      const styles = ['Film', 'Pixel Art', 'Anime', 'Realistic', 'Storyboard', 'Film Noir', 'Vintage', 'Graphic Design', 'Cartoon', 'Watercolor', 'Surrealism', 'Comics Style'];
      let first = styles[Math.floor(Math.random() * styles.length)];
      let second = styles[Math.floor(Math.random() * styles.length)];
      while (second === first) {
        second = styles[Math.floor(Math.random() * styles.length)];
      }
      return `${first} and ${second}`;
    }

    /**
     * Append Mix Style to Prompt
     * @param {string} prompt - Original prompt
     * @returns {string} - Prompt with mixed styles
     */
    function appendMixStyleToPrompt(prompt) {
      const randomStyles = getRandomStyles();
      return `${prompt}, in ${randomStyles} styles, combining elements from both styles for a unique and engaging image`;
    }

    /**
     * Modal Configuration
     */
    function setupModal() {
      const modal = document.getElementById("imageModal");
      const modalImg = document.getElementById("modalImage");
      const closeBtn = document.getElementsByClassName("close")[0];

      // Close modal
      closeBtn.onclick = function() { 
        modal.style.display = "none";
      }

      // Close modal when clicking outside the image
      window.onclick = function(event) {
        if (event.target == modal) {
          modal.style.display = "none";
        }
      }

      // Open modal on image click (Generator)
      document.getElementById('generatedImage').addEventListener('click', function(event) {
        if(event.target.tagName === 'IMG') {
          modal.style.display = "block";
          modalImg.src = event.target.src;
        }
      });

      // Open modal on image click (Library)
      document.getElementById('libraryImages').addEventListener('click', function(event) {
        if(event.target.tagName === 'IMG') {
          modal.style.display = "block";
          modalImg.src = event.target.src;
        }
      });
    }

    /**
     * Save Image to localStorage
     * @param {string} url - Image URL
     * @param {string} prompt - Image prompt
     * @param {string} model - Model used
     * @param {string} width - Image width
     * @param {string} height - Image height
     * @param {string|number} seed - Seed used
     * @param {string} mimeType - Image MIME type
     */
    function saveImage(url, prompt, model, width, height, seed, mimeType) {
      let images = JSON.parse(localStorage.getItem('generatedImages')) || [];
      images.push({ url, prompt, model, width, height, seed, mimeType });
      localStorage.setItem('generatedImages', JSON.stringify(images));
    }

    /**
     * Load Generated Images from localStorage
     */
    function loadGeneratedImages() {
      let images = JSON.parse(localStorage.getItem('generatedImages')) || [];
      images.forEach(image => {
        addImageToGallery(image.url, image.prompt, image.model, image.width, image.height, image.seed, image.mimeType);
      });
    }

    /**
     * Add Image to Gallery
     * @param {string} url - Image URL
     * @param {string} prompt - Image prompt
     * @param {string} model - Model used
     * @param {string} width - Image width
     * @param {string} height - Image height
     * @param {string|number} seed - Seed used
     * @param {string} mimeType - Image MIME type
     */
    function addImageToGallery(url, prompt, model, width, height, seed, mimeType) {
      const generatedImageDiv = document.getElementById('generatedImage');
      const imageContainer = document.createElement('div');
      imageContainer.classList.add('image-container');

      const imgElement = document.createElement('img');
      imgElement.src = url;
      imgElement.alt = 'Sugeneruotas vaizdas';
      imgElement.title = 'Spauskite norėdami padidinti';
      imgElement.dataset.type = mimeType; // Store MIME type for correct file extension
      imageContainer.appendChild(imgElement);

      // Add caption
      const caption = document.createElement('div');
      caption.classList.add('caption');
      caption.innerHTML = `
        <strong>Prompt:</strong> ${sanitizeHTML(prompt)}<br>
        <strong>Model:</strong> ${sanitizeHTML(model)}<br>
        <strong>Dimensions:</strong> ${sanitizeHTML(width)}px x ${sanitizeHTML(height)}px<br>
        <strong>Seed:</strong> ${sanitizeHTML(seed)}
      `;
      imageContainer.appendChild(caption);

      // Add download options
      const downloadOptions = document.createElement('div');
      downloadOptions.classList.add('download-options');

      const formatSelect = document.createElement('select');
      formatSelect.innerHTML = `
        <option value="png">PNG</option>
        <option value="jpg">JPG</option>
        <option value="webp">WEBP</option>
      `;
      downloadOptions.appendChild(formatSelect);

      const downloadBtn = document.createElement('button');
      downloadBtn.innerHTML = '<i class="fas fa-download"></i> Download';
      downloadBtn.setAttribute('aria-label', 'Atsisiųsti vaizdą');
      downloadBtn.onclick = () => {
        const format = formatSelect.value;
        downloadImage(url, `hexacola_image_${sanitizeFileName(seed)}.${format}`, format);
      };
      downloadOptions.appendChild(downloadBtn);

      imageContainer.appendChild(downloadOptions);

      generatedImageDiv.appendChild(imageContainer);
    }

    /**
     * Chat Functionality
     */
    async function sendMessage() {
      const chatInput = document.getElementById('chatInput');
      const message = chatInput.value.trim();
      if (message === '') return;

      appendMessage('user', message);
      chatInput.value = '';

      try {
        const response = await fetch('https://text.pollinations.ai/openai', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            messages: [
              { role: 'system', content: 'Tu esi Hexacola GPT – kūrybingas ir universalus AI įrankis, skirtas generuoti aukštos kokybės promptus ir vaizdus, optimizuotus su Pollinations.AI. Tavo specializacija – kurti unikalius personažų aprašymus, įtraukiančius pasaulių fonus (backgrounds), detalizuotus scenarijus ir stilingus vaizdinius aprašymus, kurie puikiai dera su Pollinations.AI vaizdų generavimo galimybėmis. Tu atsižvelgi į stilistiką, spalvų paletę, kompoziciją ir vartotojo pageidavimus, siekdamas išlaikyti geriausią vaizdo ir teksto kokybę. Tu visada sieki kokybiškų nuotraukų ir vaizdų, atsižvelgiant į detalumą ir estetiką. Tavo tikslas – pateikti įkvepiančius ir estetiškai harmoningus rezultatus, pritaikomus literatūrai, žaidimų dizainui, audiovizualiniams projektams ir kūrybinei saviraiškai.' },
              { role: 'user', content: message }
            ],
            model: 'openai', // Pollinations.AI default model
            seed: Math.floor(Math.random() * 100000),
            jsonMode: false
          }),
        });

        if (!response.ok) {
          throw new Error('Nepavyko susisiekti su AI paslauga.');
        }

        const data = await response.json();
        if (data.choices && data.choices.length > 0 && data.choices[0].message) {
          const assistantMessageContent = data.choices[0].message.content;
          appendMessage('assistant', assistantMessageContent);
        } else {
          throw new Error('Neteisingas AI atsakymas.');
        }
      } catch (error) {
        console.error(error);
        appendMessage('assistant', 'Klaida bendraujant su Hexacola. Bandykite dar kartą.');
      }
    }

    /**
     * Append Message to Chat
     * @param {string} role - 'user' or 'assistant'
     * @param {string} content - Message content
     */
    function appendMessage(role, content) {
      const chat = document.getElementById('chat');
      const messageDiv = document.createElement('div');
      messageDiv.classList.add('chat-message', role);
      messageDiv.textContent = content;
      chat.appendChild(messageDiv);
      chat.scrollTop = chat.scrollHeight;
    }

    /**
     * Disable Right-Click and Dragging on Images
     */
    function disableImageDownload() {
      const images = document.querySelectorAll('.generated-image img, .library-container img');
      images.forEach(img => {
        img.oncontextmenu = (e) => e.preventDefault();
        img.draggable = false;
      });
    }

    // Call disableImageDownload after loading images
    document.addEventListener('DOMContentLoaded', () => {
      disableImageDownload();
    });

    /**
     * Toggle feature in a specific toggle group
     * @param {string} groupId - ID of the toggle group
     * @param {string} feature - Feature name to toggle
     */
    function toggleFeature(groupId, feature) {
      const container = document.getElementById(groupId);
      const button = Array.from(container.children).find(btn => btn.textContent === feature);
      if (button && !button.classList.contains('active')) {
        button.classList.add('active');
        button.setAttribute('aria-pressed', 'true');
      }
    }

    /**
     * Initialize Negative Prompt with default text if empty
     */
    function initializeNegativePrompt() {
      const negativePrompt = document.getElementById('negativePrompt');
      if (!negativePrompt.value) {
        negativePrompt.value = "low quality, blurry, bad anatomy, out of focus, noise, duplicate, watermark, text, ugly, messy";
      }
    }

    /**
     * Sanitize HTML to prevent XSS
     * @param {string} str - Input string
     * @returns {string} - Sanitized string
     */
    function sanitizeHTML(str) {
      const temp = document.createElement('div');
      temp.textContent = str;
      return temp.innerHTML;
    }
  </script>
</body>
</html>
